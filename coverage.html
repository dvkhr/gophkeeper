
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>commands: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dvkhr/gophkeeper/client/cmd/commands/add.go (0.0%)</option>
				
				<option value="file1">github.com/dvkhr/gophkeeper/client/cmd/commands/delete.go (0.0%)</option>
				
				<option value="file2">github.com/dvkhr/gophkeeper/client/cmd/commands/get.go (0.0%)</option>
				
				<option value="file3">github.com/dvkhr/gophkeeper/client/cmd/commands/login.go (0.0%)</option>
				
				<option value="file4">github.com/dvkhr/gophkeeper/client/cmd/commands/logout.go (0.0%)</option>
				
				<option value="file5">github.com/dvkhr/gophkeeper/client/cmd/commands/register.go (0.0%)</option>
				
				<option value="file6">github.com/dvkhr/gophkeeper/client/cmd/commands/sync.go (0.0%)</option>
				
				<option value="file7">github.com/dvkhr/gophkeeper/client/cmd/main.go (0.0%)</option>
				
				<option value="file8">github.com/dvkhr/gophkeeper/client/cmd/version.go (0.0%)</option>
				
				<option value="file9">github.com/dvkhr/gophkeeper/client/grpc/client.go (0.0%)</option>
				
				<option value="file10">github.com/dvkhr/gophkeeper/client/internal/config/config.go (0.0%)</option>
				
				<option value="file11">github.com/dvkhr/gophkeeper/client/internal/config/validate.go (0.0%)</option>
				
				<option value="file12">github.com/dvkhr/gophkeeper/client/internal/utils/password.go (0.0%)</option>
				
				<option value="file13">github.com/dvkhr/gophkeeper/client/session/session.go (0.0%)</option>
				
				<option value="file14">github.com/dvkhr/gophkeeper/client/storage/file/filestorage.go (70.0%)</option>
				
				<option value="file15">github.com/dvkhr/gophkeeper/pb/keeper.pb.go (2.7%)</option>
				
				<option value="file16">github.com/dvkhr/gophkeeper/pb/keeper_grpc.pb.go (0.0%)</option>
				
				<option value="file17">github.com/dvkhr/gophkeeper/pkg/crypto/encryptor.go (78.6%)</option>
				
				<option value="file18">github.com/dvkhr/gophkeeper/pkg/crypto/key.go (0.0%)</option>
				
				<option value="file19">github.com/dvkhr/gophkeeper/pkg/logger/config.go (38.5%)</option>
				
				<option value="file20">github.com/dvkhr/gophkeeper/pkg/logger/handler/multi.go (41.2%)</option>
				
				<option value="file21">github.com/dvkhr/gophkeeper/pkg/logger/handler/text.go (61.9%)</option>
				
				<option value="file22">github.com/dvkhr/gophkeeper/pkg/logger/init.go (48.9%)</option>
				
				<option value="file23">github.com/dvkhr/gophkeeper/pkg/logger/level.go (33.3%)</option>
				
				<option value="file24">github.com/dvkhr/gophkeeper/pkg/logger/logger.go (75.0%)</option>
				
				<option value="file25">github.com/dvkhr/gophkeeper/pkg/logger/masker.go (0.0%)</option>
				
				<option value="file26">github.com/dvkhr/gophkeeper/server/cmd/main.go (0.0%)</option>
				
				<option value="file27">github.com/dvkhr/gophkeeper/server/internal/api/keeper-server.go (71.8%)</option>
				
				<option value="file28">github.com/dvkhr/gophkeeper/server/internal/auth/auth.go (76.0%)</option>
				
				<option value="file29">github.com/dvkhr/gophkeeper/server/internal/auth/contex.go (0.0%)</option>
				
				<option value="file30">github.com/dvkhr/gophkeeper/server/internal/auth/middleware.go (0.0%)</option>
				
				<option value="file31">github.com/dvkhr/gophkeeper/server/internal/auth/password.go (100.0%)</option>
				
				<option value="file32">github.com/dvkhr/gophkeeper/server/internal/auth/token.go (0.0%)</option>
				
				<option value="file33">github.com/dvkhr/gophkeeper/server/internal/config/config.go (0.0%)</option>
				
				<option value="file34">github.com/dvkhr/gophkeeper/server/internal/config/flags.go (0.0%)</option>
				
				<option value="file35">github.com/dvkhr/gophkeeper/server/internal/db/conn.go (85.7%)</option>
				
				<option value="file36">github.com/dvkhr/gophkeeper/server/internal/db/migrate.go (65.0%)</option>
				
				<option value="file37">github.com/dvkhr/gophkeeper/server/internal/repository/data.go (55.2%)</option>
				
				<option value="file38">github.com/dvkhr/gophkeeper/server/internal/repository/postgres.go (0.0%)</option>
				
				<option value="file39">github.com/dvkhr/gophkeeper/server/internal/repository/token.go (68.4%)</option>
				
				<option value="file40">github.com/dvkhr/gophkeeper/server/internal/repository/user.go (92.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package commands

import (
        "fmt"
        "os"
        "strings"

        "github.com/dvkhr/gophkeeper/client/session"
        "github.com/dvkhr/gophkeeper/pb"
        "github.com/urfave/cli/v2"
)

// NewAddCommand создаёт команду add
func NewAddCommand(serverAddress string) *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:  "add",
                Usage: "Добавить данные c метаинформацией",
                Flags: []cli.Flag{
                        &amp;cli.StringFlag{Name: "id", Required: true},
                        &amp;cli.StringFlag{Name: "type", Aliases: []string{"t"}, Required: true},
                        &amp;cli.StringFlag{Name: "login"},
                        &amp;cli.StringFlag{Name: "password"},
                        &amp;cli.StringFlag{Name: "number"},
                        &amp;cli.StringFlag{Name: "expiry"},
                        &amp;cli.StringFlag{Name: "cvv"},
                        &amp;cli.StringFlag{Name: "content"},
                        &amp;cli.StringFlag{Name: "file", Usage: "Путь к файлу для загрузки"},
                        &amp;cli.StringSliceFlag{Name: "meta", Aliases: []string{"m"}},
                },
                Action: func(cCtx *cli.Context) error </span><span class="cov0" title="0">{
                        client, err := session.LoadAuthenticatedClient(serverAddress)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer client.Close()

                        record, err := buildDataRecord(cCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">err = client.DoWithRetry(func() error </span><span class="cov0" title="0">{
                                resp, err := client.StoreData(record)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("Данные сохранены: %s\n", resp.Message)
                                return nil</span>
                        })

                        <span class="cov0" title="0">return err</span>
                },
        }
}

// buildDataRecord — вспомогательная функция
func buildDataRecord(cCtx *cli.Context) (*pb.DataRecord, error) <span class="cov0" title="0">{
        if err := validateFlags(cCtx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metadata := buildMetadata(cCtx)

        data, err := readData(cCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;pb.DataRecord{
                Id:            cCtx.String("id"),
                Type:          cCtx.String("type"),
                EncryptedData: data,
                Metadata:      metadata,
        }, nil</span>
}

// validateFlags проверяет, что для типа данных переданы нужные флаги
func validateFlags(cCtx *cli.Context) error <span class="cov0" title="0">{
        dataType := cCtx.String("type")
        id := cCtx.String("id")

        if id == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("требуется --id")
        }</span>

        <span class="cov0" title="0">switch dataType </span>{
        case "loginpass":<span class="cov0" title="0">
                if cCtx.String("login") == "" || cCtx.String("password") == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("для loginpass нужны --login и --password")
                }</span>
        case "card":<span class="cov0" title="0">
                if cCtx.String("number") == "" || cCtx.String("expiry") == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("для card нужны --number и --expiry")
                }</span>
        case "text":<span class="cov0" title="0">
                if cCtx.String("content") == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("для text нужен --content")
                }</span>
        case "binary":<span class="cov0" title="0">
                if cCtx.String("file") == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("для binary нужен --file")
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("неизвестный тип: %s", dataType)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// buildMetadata парсит флаг --meta в map[string]string
func buildMetadata(cCtx *cli.Context) map[string]string <span class="cov0" title="0">{
        metadata := make(map[string]string)
        for _, meta := range cCtx.StringSlice("meta") </span><span class="cov0" title="0">{
                for _, pair := range strings.Split(meta, ",") </span><span class="cov0" title="0">{
                        kv := strings.SplitN(pair, "=", 2)
                        if len(kv) == 2 </span><span class="cov0" title="0">{
                                metadata[kv[0]] = kv[1]
                        }</span>
                }
        }
        <span class="cov0" title="0">return metadata</span>
}

// readData читает данные в зависимости от типа
func readData(cCtx *cli.Context) ([]byte, error) <span class="cov0" title="0">{
        dataType := cCtx.String("type")

        if cCtx.String("file") != "" </span><span class="cov0" title="0">{
                data, err := os.ReadFile(cCtx.String("file"))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("не удалось прочитать файл: %w", err)
                }</span>
                <span class="cov0" title="0">return data, nil</span>
        }

        <span class="cov0" title="0">switch dataType </span>{
        case "loginpass":<span class="cov0" title="0">
                return []byte(fmt.Sprintf("login:%s\npassword:%s",
                        cCtx.String("login"), cCtx.String("password"))), nil</span>
        case "card":<span class="cov0" title="0">
                return []byte(fmt.Sprintf("number:%s\nexpiry:%s\ncvv:%s",
                        cCtx.String("number"), cCtx.String("expiry"), cCtx.String("cvv"))), nil</span>
        case "text":<span class="cov0" title="0">
                return []byte(cCtx.String("content")), nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("неожиданный тип: %s", dataType)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package commands

import (
        "fmt"

        "github.com/dvkhr/gophkeeper/client/grpc"
        "github.com/dvkhr/gophkeeper/client/internal/utils"
        "github.com/dvkhr/gophkeeper/client/storage/file"
        "github.com/dvkhr/gophkeeper/pkg/crypto"
        "github.com/urfave/cli/v2"
)

// NewDeleteCommand создаёт команду delete
func NewDeleteCommand(serverAddress string) *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:  "delete",
                Usage: "Удалить запись по ID",
                Flags: []cli.Flag{
                        &amp;cli.StringFlag{
                                Name:     "id",
                                Aliases:  []string{"i"},
                                Required: true,
                                Usage:    "ID записи, которую нужно удалить",
                        },
                },
                Action: func(cCtx *cli.Context) error </span><span class="cov0" title="0">{
                        id := cCtx.String("id")

                        session, err := file.Load()
                        if err != nil || session.AccessToken == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("вы не авторизованы")
                        }</span>

                        <span class="cov0" title="0">masterPassword, err := utils.ReadMasterPassword("Master-пароль: ")
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("не удалось считать пароль: %w", err)
                        }</span>
                        <span class="cov0" title="0">defer utils.ZeroBytes(masterPassword)

                        key := crypto.DeriveKey(string(masterPassword), session.Salt)

                        client, err := grpc.New(serverAddress, key)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer client.Close()

                        client.SetToken(session.AccessToken, session.RefreshToken)

                        err = client.DoWithRetry(func() error </span><span class="cov0" title="0">{
                                resp, err := client.DeleteData(id)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("%s\n", resp.Message)
                                return nil</span>
                        })

                        <span class="cov0" title="0">return err</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package commands

import (
        "fmt"
        "os"
        "strings"

        "github.com/dvkhr/gophkeeper/client/session"
        "github.com/dvkhr/gophkeeper/pb"
        "github.com/urfave/cli/v2"
)

// NewGetCommand создаёт команду get
func NewGetCommand(serverAddress string) *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:  "get",
                Usage: "Получить все сохранённые данные",
                Flags: []cli.Flag{
                        &amp;cli.StringFlag{
                                Name:  "id",
                                Usage: "ID записи (опционально, для одной записи)",
                        },
                        &amp;cli.StringFlag{
                                Name:    "output",
                                Aliases: []string{"o"},
                                Usage:   "Путь для сохранения данных (для бинарных данных)",
                        },
                },
                Action: func(cCtx *cli.Context) error </span><span class="cov0" title="0">{
                        client, err := session.LoadAuthenticatedClient(serverAddress)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer client.Close()

                        resp, err := client.GetData()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // для одной конкретной записи
                        <span class="cov0" title="0">if cCtx.String("id") != "" </span><span class="cov0" title="0">{
                                return printSingleRecord(cCtx, resp.Records)
                        }</span>

                        // Вывод всех записей
                        <span class="cov0" title="0">if len(resp.Records) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("Нет сохранённых данных")
                                return nil
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("\n Найдено записей: %d\n", len(resp.Records))
                        fmt.Println(strings.Repeat("─", 80))

                        for i, record := range resp.Records </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Println(strings.Repeat("─", 80))
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("ID:       %s\n", record.Id)
                                fmt.Printf("Тип:      %s\n", record.Type)

                                if cCtx.String("output") != "" || record.Type == "binary" </span><span class="cov0" title="0">{
                                        fmt.Printf("Данные:   (%d байт, тип %s) — используйте --output для сохранения\n", len(record.EncryptedData), record.Type)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("Данные:   %s\n", record.EncryptedData)
                                }</span>

                                <span class="cov0" title="0">if len(record.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Println("Метаданные:")
                                        for k, v := range record.Metadata </span><span class="cov0" title="0">{
                                                fmt.Printf("  %s: %s\n", k, v)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">fmt.Println(strings.Repeat("─", 80))
                        return nil</span>
                },
        }
}

// printSingleRecord выводит одну запись, можно в файл для бинарных данных
func printSingleRecord(cCtx *cli.Context, records []*pb.DataRecord) error <span class="cov0" title="0">{
        var record *pb.DataRecord
        for _, r := range records </span><span class="cov0" title="0">{
                if r.Id == cCtx.String("id") </span><span class="cov0" title="0">{
                        record = r
                        break</span>
                }
        }

        <span class="cov0" title="0">if record == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("запись с ID %s не найдена", cCtx.String("id"))
        }</span>

        <span class="cov0" title="0">outputPath := cCtx.String("output")
        if outputPath != "" </span><span class="cov0" title="0">{
                err := os.WriteFile(outputPath, record.EncryptedData, 0600)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("не удалось сохранить файл: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Файл сохранён: %s (%d байт)\n", outputPath, len(record.EncryptedData))
                return nil</span>
        }

        // Вывод в терминал (только для текстовых типов)
        <span class="cov0" title="0">if record.Type == "text" || record.Type == "loginpass" || record.Type == "card" </span><span class="cov0" title="0">{
                fmt.Printf("ID:       %s\n", record.Id)
                fmt.Printf("Тип:      %s\n", record.Type)
                fmt.Printf("Данные:   %s\n", record.EncryptedData)
                if len(record.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("Метаданные:")
                        for k, v := range record.Metadata </span><span class="cov0" title="0">{
                                fmt.Printf("  %s: %s\n", k, v)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                fmt.Printf("Тип: %s, размер: %d байт. Используйте --output для сохранения.\n", record.Type, len(record.EncryptedData))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package commands

import (
        "fmt"

        "github.com/dvkhr/gophkeeper/client/grpc"
        "github.com/dvkhr/gophkeeper/client/storage/file"
        "github.com/dvkhr/gophkeeper/pkg/crypto"
        "github.com/dvkhr/gophkeeper/pkg/logger"
        "github.com/urfave/cli/v2"
)

// NewLoginCommand создаёт команду login
func NewLoginCommand(serverAddress string) *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:  "login",
                Usage: "Войти в аккаунт",
                Flags: []cli.Flag{
                        &amp;cli.StringFlag{Name: "login", Aliases: []string{"l"}, Required: true},
                        &amp;cli.StringFlag{Name: "password", Aliases: []string{"p"}, Required: true},
                },
                Action: func(cCtx *cli.Context) error </span><span class="cov0" title="0">{
                        login := cCtx.String("login")
                        password := cCtx.String("password")

                        tempKey := crypto.DeriveKey(password, []byte("temp-salt"))
                        client, err := grpc.New(serverAddress, tempKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer client.Close()

                        resp, err := client.Login(login, []byte(password))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">session, err := file.Load()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("не удалось загрузить сессию: %w", err)
                        }</span>

                        <span class="cov0" title="0">session.AccessToken = resp.AccessToken
                        session.RefreshToken = resp.RefreshToken

                        if err := file.Save(session); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("не удалось сохранить сессию: %w", err)
                        }</span>

                        <span class="cov0" title="0">logger.Logg.Info("Успешный вход", "login", login)
                        fmt.Printf("Вы вошли как %s\n", login)
                        return nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package commands

import (
        "fmt"

        "github.com/dvkhr/gophkeeper/client/grpc"
        "github.com/dvkhr/gophkeeper/client/internal/utils"
        "github.com/dvkhr/gophkeeper/client/storage/file"
        "github.com/dvkhr/gophkeeper/pkg/crypto"
        "github.com/dvkhr/gophkeeper/pkg/logger"
        "github.com/urfave/cli/v2"
)

// NewLogoutCommand создаёт команду logout
func NewLogoutCommand(serverAddress string) *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:  "logout",
                Usage: "Выйти из аккаунта",
                Action: func(cCtx *cli.Context) error </span><span class="cov0" title="0">{
                        session, err := file.Load()
                        if err != nil || session.RefreshToken == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("вы не авторизованы")
                        }</span>

                        <span class="cov0" title="0">masterPassword, err := utils.ReadMasterPassword("Master-пароль: ")
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("не удалось считать пароль: %w", err)
                        }</span>
                        <span class="cov0" title="0">defer utils.ZeroBytes(masterPassword)

                        key := crypto.DeriveKey(string(masterPassword), session.Salt)

                        client, err := grpc.New(serverAddress, key)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer client.Close()

                        client.SetToken(session.AccessToken, session.RefreshToken)

                        err = client.Logout(session.RefreshToken)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Logg.Warn("Не удалось отозвать refresh_token на сервере", "error", err)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Logg.Info("refresh_token отозван на сервере")
                        }</span>

                        <span class="cov0" title="0">fmt.Println("Вы вышли из аккаунта")
                        return nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package commands

import (
        "fmt"

        "github.com/dvkhr/gophkeeper/client/grpc"
        "github.com/dvkhr/gophkeeper/client/storage/file"
        "github.com/dvkhr/gophkeeper/pkg/crypto"
        "github.com/dvkhr/gophkeeper/pkg/logger"
        "github.com/urfave/cli/v2"
)

// NewRegisterCommand создаёт команду register
func NewRegisterCommand(serverAddress string) *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:  "register",
                Usage: "Зарегистрировать нового пользователя",
                Flags: []cli.Flag{
                        &amp;cli.StringFlag{Name: "login", Aliases: []string{"l"}, Required: true},
                        &amp;cli.StringFlag{Name: "password", Aliases: []string{"p"}, Required: true},
                },
                Action: func(cCtx *cli.Context) error </span><span class="cov0" title="0">{
                        login := cCtx.String("login")
                        masterPassword := cCtx.String("password")

                        logger.Logg.Debug("Начало регистрации", "login", login)

                        salt, err := crypto.GenerateSalt()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Logg.Error("Не удалось сгенерировать соль", "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Logg.Debug("Соль сгенерирована", "length", len(salt))

                        key := crypto.DeriveKey(masterPassword, salt)
                        logger.Logg.Debug("Ключ шифрования сгенерирован", "key_length", len(key))

                        masterKeyHash := crypto.SHA256(key)

                        client, err := grpc.New(serverAddress, key)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Logg.Error("Не удалось создать gRPC-клиент", "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">defer client.Close()

                        logger.Logg.Info("Отправка запроса на регистрацию", "server", serverAddress)
                        resp, err := client.Register(login, []byte(masterPassword))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Logg.Error("Регистрация не удалась", "login", login, "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Logg.Debug("Регистрация успешна", "user_id", resp.UserId)

                        session := &amp;file.Data{
                                Salt:          salt,
                                MasterKeyHash: masterKeyHash,
                                AccessToken:   resp.AccessToken,
                                RefreshToken:  resp.RefreshToken,
                        }

                        if err := file.Save(session); err != nil </span><span class="cov0" title="0">{
                                logger.Logg.Error("Не удалось сохранить сессию", "error", err)
                                return fmt.Errorf("регистрация успешна, но не удалось сохранить сессию: %w", err)
                        }</span>
                        <span class="cov0" title="0">logger.Logg.Debug("Полная сессия сохранена: salt, masterKeyHash, токены")

                        fmt.Printf("Пользователь %s успешно зарегистрирован и авторизован\n", login)
                        return nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package commands

import (
        "fmt"

        "github.com/dvkhr/gophkeeper/client/session"
        "github.com/dvkhr/gophkeeper/pb"
        "github.com/urfave/cli/v2"
)

// NewSyncCommand создаёт команду sync
func NewSyncCommand(serverAddress string) *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:  "sync",
                Usage: "Синхронизировать данные с сервером",
                Action: func(cCtx *cli.Context) error </span><span class="cov0" title="0">{
                        client, err := session.LoadAuthenticatedClient(serverAddress)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer client.Close()

                        // Локальное хранилище???
                        var records []*pb.DataRecord

                        err = client.DoWithRetry(func() error </span><span class="cov0" title="0">{
                                resp, err := client.SyncData(records)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">if len(resp.Records) == 0 </span><span class="cov0" title="0">{
                                        fmt.Println("Сервер не вернул новых данных")
                                        return nil
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("Получено %d записей с сервера:\n", len(resp.Records))
                                for _, record := range resp.Records </span><span class="cov0" title="0">{
                                        fmt.Printf("  - ID: %s, Тип: %s\n", record.Id, record.Type)
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        })

                        <span class="cov0" title="0">return err</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "fmt"
        "log"
        "os"
        "time"

        "github.com/dvkhr/gophkeeper/client/cmd/commands"
        "github.com/dvkhr/gophkeeper/client/internal/config"
        "github.com/dvkhr/gophkeeper/pkg/logger"
        "github.com/urfave/cli/v2"
)

var (
        Version   = "dev"
        BuildDate = "unknown"
)

func main() <span class="cov0" title="0">{
        if err := logger.InitLogger("/home/max/go/src/GophKeeper/configs/logger.yaml"); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var flagServer string

        app := &amp;cli.App{
                Name:    "gophkeeper-client",
                Usage:   "CLI-клиент для GophKeeper",
                Version: fmt.Sprintf("%s (сборка: %s)", Version, BuildDate),
                Compiled: func() time.Time </span><span class="cov0" title="0">{
                        if BuildDate == "unknown" </span><span class="cov0" title="0">{
                                return time.Time{}
                        }</span>
                        <span class="cov0" title="0">t, _ := time.Parse("2006-01-02T15:04:05Z", BuildDate)
                        return t</span>
                }(),
                Flags: []cli.Flag{
                        &amp;cli.StringFlag{
                                Name:        "server",
                                Aliases:     []string{"s"},
                                Usage:       "Адрес gRPC-сервера",
                                Destination: &amp;flagServer,
                                EnvVars:     []string{"GK_SERVER"},
                        },
                },
                Before: func(cCtx *cli.Context) error <span class="cov0" title="0">{
                        // Загружаем конфиг из: флаг &gt; env &gt; файл
                        cfg := config.Load(flagServer)

                        for i, cmd := range cCtx.App.Commands </span><span class="cov0" title="0">{
                                switch cmd.Name </span>{
                                case "register":<span class="cov0" title="0">
                                        cCtx.App.Commands[i] = commands.NewRegisterCommand(cfg.Server.Address)</span>
                                case "add":<span class="cov0" title="0">
                                        cCtx.App.Commands[i] = commands.NewAddCommand(cfg.Server.Address)</span>
                                case "login":<span class="cov0" title="0">
                                        cCtx.App.Commands[i] = commands.NewLoginCommand(cfg.Server.Address)</span>
                                case "logout":<span class="cov0" title="0">
                                        cmd.Action = commands.NewLogoutCommand(cfg.Server.Address).Action</span>
                                case "get":<span class="cov0" title="0">
                                        cCtx.App.Commands[i] = commands.NewGetCommand(cfg.Server.Address)</span>
                                case "delete":<span class="cov0" title="0">
                                        cCtx.App.Commands[i] = commands.NewDeleteCommand(cfg.Server.Address)</span>
                                case "sync":<span class="cov0" title="0">
                                        cCtx.App.Commands[i] = commands.NewSyncCommand(cfg.Server.Address)</span>
                                }
                        }
                        <span class="cov0" title="0">return nil</span>
                },
                Commands: []*cli.Command{
                        NewVersionCommand(),
                        {Name: "register"},
                        {Name: "add"},
                        {Name: "login"},
                        {Name: "logout"},
                        {Name: "get"},
                        {Name: "delete"},
                        {Name: "sync"},
                },
        }

        <span class="cov0" title="0">if err := app.Run(os.Args); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"

        "github.com/urfave/cli/v2"
)

// NewVersionCommand возвращает команду version
func NewVersionCommand() *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:  "version",
                Usage: "Показать версию и дату сборки",
                Flags: []cli.Flag{
                        &amp;cli.BoolFlag{
                                Name:  "json",
                                Usage: "Вывести в формате JSON",
                        },
                },
                Action: func(cCtx *cli.Context) error </span><span class="cov0" title="0">{
                        if cCtx.Bool("json") </span><span class="cov0" title="0">{
                                fmt.Printf(`{"version": "%s", "build_date": "%s"}`, Version, BuildDate)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("GophKeeper CLI\n")
                                fmt.Printf("Версия: %s\n", Version)
                                fmt.Printf("Дата сборки: %s\n", BuildDate)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package grpc предоставляет gRPC-клиент для взаимодействия с сервером GophKeeper.
//
// Клиент отвечает за:
//   - Установление безопасного соединения с сервером.
//   - Шифрование и расшифровку данных с использованием AES-GCM.
//   - Аутентификацию через JWT-токены.
//   - Сохранение сессии (токенов и соли) в локальном хранилище.
//
// Все данные шифруются на клиенте, сервер хранит только зашифрованные данные.
package grpc

import (
        "context"
        "fmt"

        "github.com/dvkhr/gophkeeper/client/storage/file"
        "github.com/dvkhr/gophkeeper/pb"
        "github.com/dvkhr/gophkeeper/pkg/crypto"
        "github.com/dvkhr/gophkeeper/pkg/logger"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Client — gRPC-клиент для GophKeeper.
type Client struct {
        conn    *grpc.ClientConn
        service pb.KeeperServiceClient
        token   string
        crypto  *crypto.Encryptor
}

// New создаёт новый gRPC-клиент и устанавливает соединение с сервером.
// address — адрес сервера, например "localhost:50051"
func New(address string, encryptionKey []byte) (*Client, error) <span class="cov0" title="0">{
        clientConn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("не удалось подключиться к серверу: %w", err)
        }</span>

        <span class="cov0" title="0">encryptor, err := crypto.NewEncryptor(encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                clientConn.Close()
                return nil, fmt.Errorf("неверный ключ шифрования: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Client{
                conn:    clientConn,
                service: pb.NewKeeperServiceClient(clientConn),
                crypto:  encryptor,
        }, nil</span>
}

// Close закрывает соединение с gRPC-сервером.
func (c *Client) Close() error <span class="cov0" title="0">{
        return c.conn.Close()
}</span>

// Register регистрирует нового пользователя на сервере.
func (c *Client) Register(login string, encryptedPassword []byte) (*pb.AuthResponse, error) <span class="cov0" title="0">{
        req := &amp;pb.RegisterRequest{
                Login:             login,
                EncryptedPassword: encryptedPassword,
        }

        resp, err := c.service.Register(context.Background(), req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.token = resp.AccessToken

        return resp, nil</span>
}

// Login выполняет вход существующего пользователя.
func (c *Client) Login(login string, encryptedPassword []byte) (*pb.AuthResponse, error) <span class="cov0" title="0">{
        req := &amp;pb.LoginRequest{
                Login:             login,
                EncryptedPassword: encryptedPassword,
        }

        resp, err := c.service.Login(context.Background(), req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.token = resp.AccessToken

        return resp, nil</span>
}

// StoreData сохраняет одну запись в хранилище.
func (c *Client) StoreData(record *pb.DataRecord) (*pb.StatusResponse, error) <span class="cov0" title="0">{
        encryptedData, err := c.crypto.Encrypt(record.EncryptedData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка шифрования: %w", err)
        }</span>

        <span class="cov0" title="0">encryptedRecord := &amp;pb.DataRecord{
                Id:            record.Id,
                Type:          record.Type,
                EncryptedData: encryptedData,
                Metadata:      record.Metadata,
                Timestamp:     record.Timestamp,
        }

        ctx := c.authContext()
        resp, err := c.service.StoreData(ctx, &amp;pb.StoreDataRequest{Record: encryptedRecord})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

// GetData запрашивает все неудалённые записи пользователя.
func (c *Client) GetData() (*pb.DataResponse, error) <span class="cov0" title="0">{
        ctx := c.authContext()
        resp, err := c.service.GetData(ctx, &amp;pb.GetDataRequest{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, record := range resp.Records </span><span class="cov0" title="0">{
                plaintext, err := c.crypto.Decrypt(record.EncryptedData)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Logg.Warn("ошибка расшифрования записи ", record.Id)
                        continue</span>
                }
                <span class="cov0" title="0">record.EncryptedData = plaintext</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}

// SyncData синхронизирует список записей с сервером.
func (c *Client) SyncData(records []*pb.DataRecord) (*pb.SyncResponse, error) <span class="cov0" title="0">{
        var encryptedRecords []*pb.DataRecord
        for _, record := range records </span><span class="cov0" title="0">{
                encryptedData, err := c.crypto.Encrypt(record.EncryptedData)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка шифрования записи %s: %w", record.Id, err)
                }</span>

                <span class="cov0" title="0">encryptedRecords = append(encryptedRecords, &amp;pb.DataRecord{
                        Id:            record.Id,
                        Type:          record.Type,
                        EncryptedData: encryptedData,
                        Metadata:      record.Metadata,
                        Timestamp:     record.Timestamp,
                })</span>
        }

        <span class="cov0" title="0">ctx := c.authContext()
        req := &amp;pb.SyncRequest{Records: encryptedRecords}
        syncResp, err := c.service.SyncData(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, record := range syncResp.Records </span><span class="cov0" title="0">{
                plaintext, err := c.crypto.Decrypt(record.EncryptedData)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">record.EncryptedData = plaintext</span>
        }

        <span class="cov0" title="0">return syncResp, nil</span>
}

// DeleteData удаляет запись по ID.
func (c *Client) DeleteData(id string) (*pb.StatusResponse, error) <span class="cov0" title="0">{
        ctx := c.authContext()
        req := &amp;pb.DeleteDataRequest{Id: id}
        resp, err := c.service.DeleteData(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

// authContext возвращает контекст с заголовком авторизации (Bearer token).
// Если токен не установлен, возвращается пустой контекст.
func (c *Client) authContext() context.Context <span class="cov0" title="0">{
        if c.token == "" </span><span class="cov0" title="0">{
                return context.Background()
        }</span>

        <span class="cov0" title="0">return metadata.NewOutgoingContext(context.Background(), metadata.Pairs("authorization", "Bearer "+c.token))</span>
}

// SetToken устанавливает токен, не затрагивая другие данные.
func (c *Client) SetToken(accessToken, refreshToken string) error <span class="cov0" title="0">{
        c.token = accessToken

        session, err := file.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("не удалось загрузить сессию: %w", err)
        }</span>

        <span class="cov0" title="0">session.AccessToken = accessToken
        session.RefreshToken = refreshToken

        return file.Save(session)</span>
}

// GetToken возвращает текущий токен.
func (c *Client) GetToken() string <span class="cov0" title="0">{
        return c.token
}</span>

// Refresh обновляет пару токенов (access и refresh) на основе переданного refresh-токена.
func (c *Client) Refresh() error <span class="cov0" title="0">{
        session, err := file.Load()
        if err != nil || session.RefreshToken == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("нет refresh_token")
        }</span>

        <span class="cov0" title="0">req := &amp;pb.RefreshRequest{
                RefreshToken: session.RefreshToken,
        }

        resp, err := c.service.Refresh(context.Background(), req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.token = resp.AccessToken
        return c.SetToken(resp.AccessToken, resp.RefreshToken)</span>
}

// DoWithRetry выполняет функцию с повторной попыткой при 401
func (c *Client) DoWithRetry(fn func() error) error <span class="cov0" title="0">{
        err := fn()
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok || st.Code() != codes.Unauthenticated </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logger.Logg.Info("Попытка обновить токен...")
        if refreshErr := c.Refresh(); refreshErr != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Не удалось обновить токен", "error", refreshErr)
                return err
        }</span>

        <span class="cov0" title="0">return fn()</span>
}

// Logout отзывает refresh_token на сервере
func (c *Client) Logout(refreshToken string) error <span class="cov0" title="0">{
        req := &amp;pb.LogoutRequest{
                RefreshToken: refreshToken,
        }
        _, err := c.service.Logout(context.Background(), req)
        return err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "os"

        "github.com/dvkhr/gophkeeper/pkg/logger"
        "gopkg.in/yaml.v3"
)

const configFilePath = "/home/max/go/src/GophKeeper/configs/client.yaml"

type Config struct {
        Server struct {
                Address string `yaml:"address"`
        } `yaml:"server"`
}

func Load(flagAddress string) *Config <span class="cov0" title="0">{
        cfg := &amp;Config{}

        loadFromFile(cfg)

        if envAddr := os.Getenv("GK_SERVER"); envAddr != "" </span><span class="cov0" title="0">{
                if err := ValidateServerAddress(envAddr); err != nil </span><span class="cov0" title="0">{
                        logger.Logg.Warn("Invalid server address in GK_SERVER, skipped",
                                "error", err)
                }</span> else<span class="cov0" title="0"> {
                        cfg.Server.Address = envAddr
                        logger.Logg.Info("Конфиг: адрес из переменной окружения", "GK_SERVER", envAddr)
                }</span>
        }

        <span class="cov0" title="0">if flagAddress != "" </span><span class="cov0" title="0">{
                if err := ValidateServerAddress(flagAddress); err != nil </span><span class="cov0" title="0">{
                        logger.Logg.Error("Invalid server address in --server flag",
                                "error", err,
                                "address", flagAddress)
                }</span> else<span class="cov0" title="0"> {
                        cfg.Server.Address = flagAddress
                        logger.Logg.Info("Конфиг: адрес из флага --server", "address", flagAddress)
                }</span>
        }

        <span class="cov0" title="0">if cfg.Server.Address == "" </span><span class="cov0" title="0">{
                cfg.Server.Address = "localhost:50051"
                logger.Logg.Info("Конфиг: использован адрес по умолчанию", "address", cfg.Server.Address)
        }</span> else<span class="cov0" title="0"> {
                if err := ValidateServerAddress(cfg.Server.Address); err != nil </span><span class="cov0" title="0">{
                        logger.Logg.Warn("Invalid server address from config file, using default",
                                "error", err)
                        cfg.Server.Address = "localhost:50051"
                }</span>
        }

        <span class="cov0" title="0">return cfg</span>
}

// loadFromFile загружает конфигурацию из YAML-файла, если он существует.
// Игнорирует все ошибки, логгируя их на уровне WARN.
// Не возвращает ошибку, так как файл не обязателен.
func loadFromFile(cfg *Config) <span class="cov0" title="0">{

        if _, err := os.Stat(configFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                logger.Logg.Warn("Конфигурационный файл не найден", "path", configFilePath)
                return
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(configFilePath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Warn("Не удалось прочитать конфигурационный файл",
                        "path", configFilePath,
                        "error", err)
                return
        }</span>

        <span class="cov0" title="0">if err := yaml.Unmarshal(data, cfg); err != nil </span><span class="cov0" title="0">{
                logger.Logg.Warn("Не удалось разобрать YAML-конфиг",
                        "path", configFilePath,
                        "error", err)
                return
        }</span>

        <span class="cov0" title="0">logger.Logg.Info("Конфигурация успешно загружена из файла", "path", configFilePath)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package config

import (
        "fmt"
        "net"
)

// ValidateServerAddress проверяет, что адрес имеет формат host:port и порт валиден
func ValidateServerAddress(address string) error <span class="cov0" title="0">{
        if address == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("server address cannot be empty")
        }</span>

        <span class="cov0" title="0">host, port, err := net.SplitHostPort(address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid server address format '%s': must be host:port", address)
        }</span>

        <span class="cov0" title="0">if host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing host in server address: %s", address)
        }</span>

        <span class="cov0" title="0">portInt, err := net.LookupPort("tcp", port)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid port in server address '%s': %v", address, err)
        }</span>

        <span class="cov0" title="0">if portInt &lt;= 0 || portInt &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("port must be in range 1-65535, got %d", portInt)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package utils

import (
        "fmt"
        "syscall"

        "golang.org/x/term"
)

// ReadMasterPassword запрашивает мастер-пароль со скрытым вводом
func ReadMasterPassword(prompt string) ([]byte, error) <span class="cov0" title="0">{
        fmt.Print(prompt)
        password, err := term.ReadPassword(int(syscall.Stdin))
        fmt.Println()
        return password, err
}</span>

// ZeroBytes обнуляет байты в памяти для безопасности
func ZeroBytes(b []byte) <span class="cov0" title="0">{
        for i := range b </span><span class="cov0" title="0">{
                b[i] = 0
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package session

import (
        "bytes"
        "fmt"

        "github.com/dvkhr/gophkeeper/client/grpc"
        "github.com/dvkhr/gophkeeper/client/internal/utils"
        "github.com/dvkhr/gophkeeper/client/storage/file"
        "github.com/dvkhr/gophkeeper/pkg/crypto"
)

// Manager управляет сессией клиента: загрузка соли, ввод пароля, создание gRPC-клиента
type Manager struct {
        address string
}

// NewManager создаёт новый менеджер сессии
func NewManager(address string) *Manager <span class="cov0" title="0">{
        return &amp;Manager{address: address}
}</span>

// NewClient создаёт и настраивает gRPC-клиент
func (m *Manager) NewClient() (*grpc.Client, error) <span class="cov0" title="0">{
        session, err := file.Load()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("не удалось загрузить сессию: %w", err)
        }</span>

        <span class="cov0" title="0">if session.Salt == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("соль не найдена. Выполните регистрацию")
        }</span>

        <span class="cov0" title="0">masterPassword := "master-pass-placeholder" // ← заменим на realPassword()

        key := crypto.DeriveKey(masterPassword, session.Salt)

        client, err := grpc.New(m.address, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("не удалось создать gRPC-клиент: %w", err)
        }</span>

        <span class="cov0" title="0">if session.AccessToken != "" &amp;&amp; session.RefreshToken != "" </span><span class="cov0" title="0">{
                _ = client.SetToken(session.AccessToken, session.RefreshToken)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// NewClientWithPassword создаёт клиент, используя переданный мастер-пароль
func (m *Manager) NewClientWithPassword(masterPassword string) (*grpc.Client, error) <span class="cov0" title="0">{
        session, err := file.Load()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("не удалось загрузить сессию: %w", err)
        }</span>

        <span class="cov0" title="0">if session.Salt == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("соль не найдена")
        }</span>

        <span class="cov0" title="0">key := crypto.DeriveKey(masterPassword, session.Salt)
        client, err := grpc.New(m.address, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Если токены есть — восстанавливаем
        <span class="cov0" title="0">if session.AccessToken != "" &amp;&amp; session.RefreshToken != "" </span><span class="cov0" title="0">{
                _ = client.SetToken(session.AccessToken, session.RefreshToken)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// LoadAuthenticatedClient загружает сессию, запрашивает мастер-пароль,
// проверяет его корректность и возвращает готовый к использованию gRPC-клиент.
func LoadAuthenticatedClient(serverAddress string) (*grpc.Client, error) <span class="cov0" title="0">{
        session, err := file.Load()
        if err != nil || session.AccessToken == "" </span><span class="cov0" title="0">{
                return nil, errUnauthorized
        }</span>

        <span class="cov0" title="0">masterPassword, err := utils.ReadMasterPassword("Master-пароль: ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer utils.ZeroBytes(masterPassword)

        inputKey := crypto.DeriveKey(string(masterPassword), session.Salt)
        inputKeyHash := crypto.SHA256(inputKey)

        if !bytes.Equal(inputKeyHash, session.MasterKeyHash) </span><span class="cov0" title="0">{
                utils.ZeroBytes(masterPassword)
                return nil, errInvalidMasterPassword
        }</span>

        <span class="cov0" title="0">client, err := grpc.New(serverAddress, inputKey)
        if err != nil </span><span class="cov0" title="0">{
                utils.ZeroBytes(masterPassword)
                return nil, err
        }</span>

        <span class="cov0" title="0">client.SetToken(session.AccessToken, session.RefreshToken)

        return client, nil</span>
}

// Ошибки
var (
        errUnauthorized          = fmt.Errorf("вы не авторизованы")
        errInvalidMasterPassword = fmt.Errorf("неверный мастер-пароль — данные не могут быть зашифрованы")
)
</pre>
		
		<pre class="file" id="file14" style="display: none">package file

import (
        "encoding/json"
        "os"
        "path/filepath"
        "runtime"
)

// Data — данные, которые хранятся в файле
type Data struct {
        Salt          []byte `json:"salt,omitempty"`
        AccessToken   string `json:"access_token,omitempty"`
        RefreshToken  string `json:"refresh_token,omitempty"`
        MasterKeyHash []byte `json:"master_key_hash,omitempty"`
}

// getPath возвращает путь к файлу данных
func getPath() string <span class="cov10" title="10">{
        var dir string
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                dir = os.Getenv("APPDATA")
        }</span> else<span class="cov10" title="10"> {
                home := os.Getenv("HOME")
                dir = filepath.Join(home, ".config")
                // Создаём директорию, если её нет
                _ = os.MkdirAll(dir, 0700)
        }</span>

        <span class="cov10" title="10">return filepath.Join(dir, ".gophkeeper.json")</span>
}

// Save сохраняет данные в файл с правами 0600
func Save(data *Data) error <span class="cov5" title="3">{
        path := getPath()
        fileData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="3">return os.WriteFile(path, fileData, 0600)</span>
}

// Load загружает данные из файла
func Load() (*Data, error) <span class="cov5" title="3">{
        path := getPath()

        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov1" title="1">{
                // Файл ещё не создан
                return &amp;Data{}, nil
        }</span>

        <span class="cov3" title="2">fileData, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">var data Data
        err = json.Unmarshal(fileData, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">return &amp;data, nil</span>
}

// Clear удаляет файл
func Clear() error <span class="cov1" title="1">{
        path := getPath()
        return os.Remove(path)
}</span>

// Delete удаляет файл сессии
func Delete() error <span class="cov0" title="0">{
        configDir, err := os.UserConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := filepath.Join(configDir, ".gophkeeper.json")

        return os.Remove(path)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v3.21.12
// source: proto/keeper.proto

package pb

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// RegisterRequest содержит данные для регистрации нового пользователя
type RegisterRequest struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        Login             string                 `protobuf:"bytes,1,opt,name=login,proto3" json:"login,omitempty"`                                                  // Логин пользователя
        EncryptedPassword []byte                 `protobuf:"bytes,2,opt,name=encrypted_password,json=encryptedPassword,proto3" json:"encrypted_password,omitempty"` // Зашифрованный пароль
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        mi := &amp;file_proto_keeper_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{0}
}</span>

func (x *RegisterRequest) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetEncryptedPassword() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EncryptedPassword
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// LoginRequest содержит данные для входа пользователя
type LoginRequest struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        Login             string                 `protobuf:"bytes,1,opt,name=login,proto3" json:"login,omitempty"`                                                  // Логин пользователя
        EncryptedPassword []byte                 `protobuf:"bytes,2,opt,name=encrypted_password,json=encryptedPassword,proto3" json:"encrypted_password,omitempty"` // Зашифрованный пароль
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        mi := &amp;file_proto_keeper_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{1}
}</span>

func (x *LoginRequest) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetEncryptedPassword() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EncryptedPassword
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AuthResponse возвращается после успешной регистрации или входа
type AuthResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`    // JWT-токен доступа
        RefreshToken  string                 `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"` // Refresh-токен
        UserId        string                 `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`                   // user_id
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AuthResponse) Reset() <span class="cov0" title="0">{
        *x = AuthResponse{}
        mi := &amp;file_proto_keeper_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AuthResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AuthResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AuthResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AuthResponse.ProtoReflect.Descriptor instead.
func (*AuthResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{2}
}</span>

func (x *AuthResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthResponse) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// DataRecord представляет одну запись данных пользователя
type DataRecord struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`                                                                                       // Уникальный идентификатор записи
        Type          string                 `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`                                                                                   // Тип данных: loginpass, text, binary, card
        EncryptedData []byte                 `protobuf:"bytes,3,opt,name=encrypted_data,json=encryptedData,proto3" json:"encrypted_data,omitempty"`                                            // Зашифрованное содержимое данных
        Metadata      map[string]string      `protobuf:"bytes,4,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Метаданные (например: сайт, банк, личность)
        Timestamp     int64                  `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                                                                        // Время последнего изменения (Unix timestamp)
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DataRecord) Reset() <span class="cov0" title="0">{
        *x = DataRecord{}
        mi := &amp;file_proto_keeper_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DataRecord) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataRecord) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataRecord) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataRecord.ProtoReflect.Descriptor instead.
func (*DataRecord) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{3}
}</span>

func (x *DataRecord) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataRecord) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataRecord) GetEncryptedData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EncryptedData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataRecord) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataRecord) GetTimestamp() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// SyncRequest используется для синхронизации данных между клиентом и сервером
type SyncRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Records       []*DataRecord          `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"` // Список записей для синхронизации
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SyncRequest) Reset() <span class="cov0" title="0">{
        *x = SyncRequest{}
        mi := &amp;file_proto_keeper_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SyncRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SyncRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SyncRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SyncRequest.ProtoReflect.Descriptor instead.
func (*SyncRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{4}
}</span>

func (x *SyncRequest) GetRecords() []*DataRecord <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Records
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SyncResponse возвращает обновлённые данные после синхронизации
type SyncResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Records       []*DataRecord          `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"` // Обновлённые или добавленные записи
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SyncResponse) Reset() <span class="cov0" title="0">{
        *x = SyncResponse{}
        mi := &amp;file_proto_keeper_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SyncResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SyncResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SyncResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SyncResponse.ProtoReflect.Descriptor instead.
func (*SyncResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{5}
}</span>

func (x *SyncResponse) GetRecords() []*DataRecord <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Records
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDataRequest запрашивает данные определённого типа
type GetDataRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Type          string                 `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"` // Тип данных: loginpass, text, binary, card
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetDataRequest) Reset() <span class="cov0" title="0">{
        *x = GetDataRequest{}
        mi := &amp;file_proto_keeper_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetDataRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetDataRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetDataRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetDataRequest.ProtoReflect.Descriptor instead.
func (*GetDataRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetDataRequest) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// DataResponse возвращает список данных заданного типа
type DataResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Records       []*DataRecord          `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"` // Найденные записи
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DataResponse) Reset() <span class="cov0" title="0">{
        *x = DataResponse{}
        mi := &amp;file_proto_keeper_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DataResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataResponse.ProtoReflect.Descriptor instead.
func (*DataResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{7}
}</span>

func (x *DataResponse) GetRecords() []*DataRecord <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Records
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// StoreDataRequest используется для сохранения одной записи
type StoreDataRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Record        *DataRecord            `protobuf:"bytes,1,opt,name=record,proto3" json:"record,omitempty"` // Запись, которую нужно сохранить
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StoreDataRequest) Reset() <span class="cov0" title="0">{
        *x = StoreDataRequest{}
        mi := &amp;file_proto_keeper_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StoreDataRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StoreDataRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StoreDataRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StoreDataRequest.ProtoReflect.Descriptor instead.
func (*StoreDataRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{8}
}</span>

func (x *StoreDataRequest) GetRecord() *DataRecord <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Record
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// StatusResponse возвращается как результат операции
type StatusResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"` // Успешно ли выполнено
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`  // Сообщение с результатом
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatusResponse) Reset() <span class="cov0" title="0">{
        *x = StatusResponse{}
        mi := &amp;file_proto_keeper_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatusResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatusResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatusResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatusResponse.ProtoReflect.Descriptor instead.
func (*StatusResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{9}
}</span>

func (x *StatusResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StatusResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Запрос на удаление данных
type DeleteDataRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // Идентификатор записи
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteDataRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteDataRequest{}
        mi := &amp;file_proto_keeper_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteDataRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteDataRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteDataRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteDataRequest.ProtoReflect.Descriptor instead.
func (*DeleteDataRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{10}
}</span>

func (x *DeleteDataRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RefreshRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        RefreshToken  string                 `protobuf:"bytes,1,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"` // Токен для обновления сессии
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RefreshRequest) Reset() <span class="cov0" title="0">{
        *x = RefreshRequest{}
        mi := &amp;file_proto_keeper_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RefreshRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshRequest.ProtoReflect.Descriptor instead.
func (*RefreshRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{11}
}</span>

func (x *RefreshRequest) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LogoutRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        RefreshToken  string                 `protobuf:"bytes,1,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogoutRequest) Reset() <span class="cov0" title="0">{
        *x = LogoutRequest{}
        mi := &amp;file_proto_keeper_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{12}
}</span>

func (x *LogoutRequest) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LogoutResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogoutResponse) Reset() <span class="cov0" title="0">{
        *x = LogoutResponse{}
        mi := &amp;file_proto_keeper_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_keeper_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.
func (*LogoutResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_keeper_proto_rawDescGZIP(), []int{13}
}</span>

func (x *LogoutResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_proto_keeper_proto protoreflect.FileDescriptor

const file_proto_keeper_proto_rawDesc = "" +
        "\n" +
        "\x12proto/keeper.proto\x12\x06keeper\"V\n" +
        "\x0fRegisterRequest\x12\x14\n" +
        "\x05login\x18\x01 \x01(\tR\x05login\x12-\n" +
        "\x12encrypted_password\x18\x02 \x01(\fR\x11encryptedPassword\"S\n" +
        "\fLoginRequest\x12\x14\n" +
        "\x05login\x18\x01 \x01(\tR\x05login\x12-\n" +
        "\x12encrypted_password\x18\x02 \x01(\fR\x11encryptedPassword\"o\n" +
        "\fAuthResponse\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12#\n" +
        "\rrefresh_token\x18\x02 \x01(\tR\frefreshToken\x12\x17\n" +
        "\auser_id\x18\x03 \x01(\tR\x06userId\"\xf0\x01\n" +
        "\n" +
        "DataRecord\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04type\x18\x02 \x01(\tR\x04type\x12%\n" +
        "\x0eencrypted_data\x18\x03 \x01(\fR\rencryptedData\x12&lt;\n" +
        "\bmetadata\x18\x04 \x03(\v2 .keeper.DataRecord.MetadataEntryR\bmetadata\x12\x1c\n" +
        "\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\";\n" +
        "\vSyncRequest\x12,\n" +
        "\arecords\x18\x01 \x03(\v2\x12.keeper.DataRecordR\arecords\"&lt;\n" +
        "\fSyncResponse\x12,\n" +
        "\arecords\x18\x01 \x03(\v2\x12.keeper.DataRecordR\arecords\"$\n" +
        "\x0eGetDataRequest\x12\x12\n" +
        "\x04type\x18\x01 \x01(\tR\x04type\"&lt;\n" +
        "\fDataResponse\x12,\n" +
        "\arecords\x18\x01 \x03(\v2\x12.keeper.DataRecordR\arecords\"&gt;\n" +
        "\x10StoreDataRequest\x12*\n" +
        "\x06record\x18\x01 \x01(\v2\x12.keeper.DataRecordR\x06record\"D\n" +
        "\x0eStatusResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\"#\n" +
        "\x11DeleteDataRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"5\n" +
        "\x0eRefreshRequest\x12#\n" +
        "\rrefresh_token\x18\x01 \x01(\tR\frefreshToken\"4\n" +
        "\rLogoutRequest\x12#\n" +
        "\rrefresh_token\x18\x01 \x01(\tR\frefreshToken\"*\n" +
        "\x0eLogoutResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess2\xe1\x03\n" +
        "\rKeeperService\x129\n" +
        "\bRegister\x12\x17.keeper.RegisterRequest\x1a\x14.keeper.AuthResponse\x123\n" +
        "\x05Login\x12\x14.keeper.LoginRequest\x1a\x14.keeper.AuthResponse\x127\n" +
        "\x06Logout\x12\x15.keeper.LogoutRequest\x1a\x16.keeper.LogoutResponse\x125\n" +
        "\bSyncData\x12\x13.keeper.SyncRequest\x1a\x14.keeper.SyncResponse\x127\n" +
        "\aGetData\x12\x16.keeper.GetDataRequest\x1a\x14.keeper.DataResponse\x12=\n" +
        "\tStoreData\x12\x18.keeper.StoreDataRequest\x1a\x16.keeper.StatusResponse\x12?\n" +
        "\n" +
        "DeleteData\x12\x19.keeper.DeleteDataRequest\x1a\x16.keeper.StatusResponse\x127\n" +
        "\aRefresh\x12\x16.keeper.RefreshRequest\x1a\x14.keeper.AuthResponseB Z\x1egithub.com/dvkhr/gophkeeper/pbb\x06proto3"

var (
        file_proto_keeper_proto_rawDescOnce sync.Once
        file_proto_keeper_proto_rawDescData []byte
)

func file_proto_keeper_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_keeper_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_keeper_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_keeper_proto_rawDesc), len(file_proto_keeper_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_keeper_proto_rawDescData</span>
}

var file_proto_keeper_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_proto_keeper_proto_goTypes = []any{
        (*RegisterRequest)(nil),   // 0: keeper.RegisterRequest
        (*LoginRequest)(nil),      // 1: keeper.LoginRequest
        (*AuthResponse)(nil),      // 2: keeper.AuthResponse
        (*DataRecord)(nil),        // 3: keeper.DataRecord
        (*SyncRequest)(nil),       // 4: keeper.SyncRequest
        (*SyncResponse)(nil),      // 5: keeper.SyncResponse
        (*GetDataRequest)(nil),    // 6: keeper.GetDataRequest
        (*DataResponse)(nil),      // 7: keeper.DataResponse
        (*StoreDataRequest)(nil),  // 8: keeper.StoreDataRequest
        (*StatusResponse)(nil),    // 9: keeper.StatusResponse
        (*DeleteDataRequest)(nil), // 10: keeper.DeleteDataRequest
        (*RefreshRequest)(nil),    // 11: keeper.RefreshRequest
        (*LogoutRequest)(nil),     // 12: keeper.LogoutRequest
        (*LogoutResponse)(nil),    // 13: keeper.LogoutResponse
        nil,                       // 14: keeper.DataRecord.MetadataEntry
}
var file_proto_keeper_proto_depIdxs = []int32{
        14, // 0: keeper.DataRecord.metadata:type_name -&gt; keeper.DataRecord.MetadataEntry
        3,  // 1: keeper.SyncRequest.records:type_name -&gt; keeper.DataRecord
        3,  // 2: keeper.SyncResponse.records:type_name -&gt; keeper.DataRecord
        3,  // 3: keeper.DataResponse.records:type_name -&gt; keeper.DataRecord
        3,  // 4: keeper.StoreDataRequest.record:type_name -&gt; keeper.DataRecord
        0,  // 5: keeper.KeeperService.Register:input_type -&gt; keeper.RegisterRequest
        1,  // 6: keeper.KeeperService.Login:input_type -&gt; keeper.LoginRequest
        12, // 7: keeper.KeeperService.Logout:input_type -&gt; keeper.LogoutRequest
        4,  // 8: keeper.KeeperService.SyncData:input_type -&gt; keeper.SyncRequest
        6,  // 9: keeper.KeeperService.GetData:input_type -&gt; keeper.GetDataRequest
        8,  // 10: keeper.KeeperService.StoreData:input_type -&gt; keeper.StoreDataRequest
        10, // 11: keeper.KeeperService.DeleteData:input_type -&gt; keeper.DeleteDataRequest
        11, // 12: keeper.KeeperService.Refresh:input_type -&gt; keeper.RefreshRequest
        2,  // 13: keeper.KeeperService.Register:output_type -&gt; keeper.AuthResponse
        2,  // 14: keeper.KeeperService.Login:output_type -&gt; keeper.AuthResponse
        13, // 15: keeper.KeeperService.Logout:output_type -&gt; keeper.LogoutResponse
        5,  // 16: keeper.KeeperService.SyncData:output_type -&gt; keeper.SyncResponse
        7,  // 17: keeper.KeeperService.GetData:output_type -&gt; keeper.DataResponse
        9,  // 18: keeper.KeeperService.StoreData:output_type -&gt; keeper.StatusResponse
        9,  // 19: keeper.KeeperService.DeleteData:output_type -&gt; keeper.StatusResponse
        2,  // 20: keeper.KeeperService.Refresh:output_type -&gt; keeper.AuthResponse
        13, // [13:21] is the sub-list for method output_type
        5,  // [5:13] is the sub-list for method input_type
        5,  // [5:5] is the sub-list for extension type_name
        5,  // [5:5] is the sub-list for extension extendee
        0,  // [0:5] is the sub-list for field type_name
}

func init() <span class="cov10" title="3">{ file_proto_keeper_proto_init() }</span>
func file_proto_keeper_proto_init() <span class="cov10" title="3">{
        if File_proto_keeper_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="3">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_keeper_proto_rawDesc), len(file_proto_keeper_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   15,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_keeper_proto_goTypes,
                DependencyIndexes: file_proto_keeper_proto_depIdxs,
                MessageInfos:      file_proto_keeper_proto_msgTypes,
        }.Build()
        File_proto_keeper_proto = out.File
        file_proto_keeper_proto_goTypes = nil
        file_proto_keeper_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: proto/keeper.proto

package pb

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        KeeperService_Register_FullMethodName   = "/keeper.KeeperService/Register"
        KeeperService_Login_FullMethodName      = "/keeper.KeeperService/Login"
        KeeperService_Logout_FullMethodName     = "/keeper.KeeperService/Logout"
        KeeperService_SyncData_FullMethodName   = "/keeper.KeeperService/SyncData"
        KeeperService_GetData_FullMethodName    = "/keeper.KeeperService/GetData"
        KeeperService_StoreData_FullMethodName  = "/keeper.KeeperService/StoreData"
        KeeperService_DeleteData_FullMethodName = "/keeper.KeeperService/DeleteData"
        KeeperService_Refresh_FullMethodName    = "/keeper.KeeperService/Refresh"
)

// KeeperServiceClient is the client API for KeeperService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// KeeperService предоставляет функционал для регистрации, аутентификации,
// хранения и синхронизации защищённых данных пользователя.
type KeeperServiceClient interface {
        // Register регистрирует нового пользователя
        Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*AuthResponse, error)
        // Login выполняет вход пользователя и выдачу токенов
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*AuthResponse, error)
        // Logout выполняет выход пользователя и отзыв токена
        Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
        // SyncData синхронизирует данные между клиентом и сервером
        SyncData(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error)
        // GetData возвращает данные указанного типа
        GetData(ctx context.Context, in *GetDataRequest, opts ...grpc.CallOption) (*DataResponse, error)
        // StoreData сохраняет новую запись на сервере
        StoreData(ctx context.Context, in *StoreDataRequest, opts ...grpc.CallOption) (*StatusResponse, error)
        // DeleteData удаляет запись (помечает как удалённую)
        DeleteData(ctx context.Context, in *DeleteDataRequest, opts ...grpc.CallOption) (*StatusResponse, error)
        // Refresh обновляет токены
        Refresh(ctx context.Context, in *RefreshRequest, opts ...grpc.CallOption) (*AuthResponse, error)
}

type keeperServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewKeeperServiceClient(cc grpc.ClientConnInterface) KeeperServiceClient <span class="cov0" title="0">{
        return &amp;keeperServiceClient{cc}
}</span>

func (c *keeperServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*AuthResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AuthResponse)
        err := c.cc.Invoke(ctx, KeeperService_Register_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*AuthResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AuthResponse)
        err := c.cc.Invoke(ctx, KeeperService_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LogoutResponse)
        err := c.cc.Invoke(ctx, KeeperService_Logout_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperServiceClient) SyncData(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SyncResponse)
        err := c.cc.Invoke(ctx, KeeperService_SyncData_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperServiceClient) GetData(ctx context.Context, in *GetDataRequest, opts ...grpc.CallOption) (*DataResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DataResponse)
        err := c.cc.Invoke(ctx, KeeperService_GetData_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperServiceClient) StoreData(ctx context.Context, in *StoreDataRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, KeeperService_StoreData_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperServiceClient) DeleteData(ctx context.Context, in *DeleteDataRequest, opts ...grpc.CallOption) (*StatusResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatusResponse)
        err := c.cc.Invoke(ctx, KeeperService_DeleteData_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperServiceClient) Refresh(ctx context.Context, in *RefreshRequest, opts ...grpc.CallOption) (*AuthResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AuthResponse)
        err := c.cc.Invoke(ctx, KeeperService_Refresh_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// KeeperServiceServer is the server API for KeeperService service.
// All implementations must embed UnimplementedKeeperServiceServer
// for forward compatibility.
//
// KeeperService предоставляет функционал для регистрации, аутентификации,
// хранения и синхронизации защищённых данных пользователя.
type KeeperServiceServer interface {
        // Register регистрирует нового пользователя
        Register(context.Context, *RegisterRequest) (*AuthResponse, error)
        // Login выполняет вход пользователя и выдачу токенов
        Login(context.Context, *LoginRequest) (*AuthResponse, error)
        // Logout выполняет выход пользователя и отзыв токена
        Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
        // SyncData синхронизирует данные между клиентом и сервером
        SyncData(context.Context, *SyncRequest) (*SyncResponse, error)
        // GetData возвращает данные указанного типа
        GetData(context.Context, *GetDataRequest) (*DataResponse, error)
        // StoreData сохраняет новую запись на сервере
        StoreData(context.Context, *StoreDataRequest) (*StatusResponse, error)
        // DeleteData удаляет запись (помечает как удалённую)
        DeleteData(context.Context, *DeleteDataRequest) (*StatusResponse, error)
        // Refresh обновляет токены
        Refresh(context.Context, *RefreshRequest) (*AuthResponse, error)
        mustEmbedUnimplementedKeeperServiceServer()
}

// UnimplementedKeeperServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKeeperServiceServer struct{}

func (UnimplementedKeeperServiceServer) Register(context.Context, *RegisterRequest) (*AuthResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}</span>
func (UnimplementedKeeperServiceServer) Login(context.Context, *LoginRequest) (*AuthResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedKeeperServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}</span>
func (UnimplementedKeeperServiceServer) SyncData(context.Context, *SyncRequest) (*SyncResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SyncData not implemented")
}</span>
func (UnimplementedKeeperServiceServer) GetData(context.Context, *GetDataRequest) (*DataResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetData not implemented")
}</span>
func (UnimplementedKeeperServiceServer) StoreData(context.Context, *StoreDataRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method StoreData not implemented")
}</span>
func (UnimplementedKeeperServiceServer) DeleteData(context.Context, *DeleteDataRequest) (*StatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteData not implemented")
}</span>
func (UnimplementedKeeperServiceServer) Refresh(context.Context, *RefreshRequest) (*AuthResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}</span>
func (UnimplementedKeeperServiceServer) mustEmbedUnimplementedKeeperServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedKeeperServiceServer) testEmbeddedByValue()                       {<span class="cov0" title="0">}</span>

// UnsafeKeeperServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeeperServiceServer will
// result in compilation errors.
type UnsafeKeeperServiceServer interface {
        mustEmbedUnimplementedKeeperServiceServer()
}

func RegisterKeeperServiceServer(s grpc.ServiceRegistrar, srv KeeperServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedKeeperServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;KeeperService_ServiceDesc, srv)</span>
}

func _KeeperService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).Register(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KeeperService_Register_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).Register(ctx, req.(*RegisterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KeeperService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KeeperService_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KeeperService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LogoutRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).Logout(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KeeperService_Logout_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).Logout(ctx, req.(*LogoutRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KeeperService_SyncData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SyncRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).SyncData(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KeeperService_SyncData_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).SyncData(ctx, req.(*SyncRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KeeperService_GetData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetDataRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).GetData(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KeeperService_GetData_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).GetData(ctx, req.(*GetDataRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KeeperService_StoreData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StoreDataRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).StoreData(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KeeperService_StoreData_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).StoreData(ctx, req.(*StoreDataRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KeeperService_DeleteData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteDataRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).DeleteData(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KeeperService_DeleteData_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).DeleteData(ctx, req.(*DeleteDataRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KeeperService_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RefreshRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).Refresh(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: KeeperService_Refresh_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServiceServer).Refresh(ctx, req.(*RefreshRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// KeeperService_ServiceDesc is the grpc.ServiceDesc for KeeperService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeeperService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "keeper.KeeperService",
        HandlerType: (*KeeperServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Register",
                        Handler:    _KeeperService_Register_Handler,
                },
                {
                        MethodName: "Login",
                        Handler:    _KeeperService_Login_Handler,
                },
                {
                        MethodName: "Logout",
                        Handler:    _KeeperService_Logout_Handler,
                },
                {
                        MethodName: "SyncData",
                        Handler:    _KeeperService_SyncData_Handler,
                },
                {
                        MethodName: "GetData",
                        Handler:    _KeeperService_GetData_Handler,
                },
                {
                        MethodName: "StoreData",
                        Handler:    _KeeperService_StoreData_Handler,
                },
                {
                        MethodName: "DeleteData",
                        Handler:    _KeeperService_DeleteData_Handler,
                },
                {
                        MethodName: "Refresh",
                        Handler:    _KeeperService_Refresh_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/keeper.proto",
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package crypto

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "errors"
        "io"
)

// Encryptor предоставляет методы для шифрования и расшифровки данных с использованием AES-GCM.
type Encryptor struct {
        key []byte
}

// NewEncryptor создаёт новый экземпляр Encryptor с ключом.
// Ключ должен быть длиной 16, 24 или 32 байта (AES-128, 192, 256).
func NewEncryptor(key []byte) (*Encryptor, error) <span class="cov10" title="4">{
        if len(key) != 16 &amp;&amp; len(key) != 24 &amp;&amp; len(key) != 32 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key size: must be 16, 24, or 32 bytes")
        }</span>
        <span class="cov8" title="3">return &amp;Encryptor{key: key}, nil</span>
}

// Encrypt шифрует данные с использованием AES-GCM.
// Возвращает зашифрованные данные в формате: [nonce][ciphertext]
func (e *Encryptor) Encrypt(plaintext []byte) ([]byte, error) <span class="cov5" title="2">{
        block, err := aes.NewCipher(e.key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)

        return ciphertext, nil</span>
}

// Decrypt расшифровывает данные, ожидает формат: [nonce][ciphertext]
func (e *Encryptor) Decrypt(ciphertext []byte) ([]byte, error) <span class="cov5" title="2">{
        block, err := aes.NewCipher(e.key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">nonceSize := gcm.NonceSize()
        if len(ciphertext) &lt; nonceSize </span><span class="cov0" title="0">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov5" title="2">nonce, encrypted := ciphertext[:nonceSize], ciphertext[nonceSize:]
        plaintext, err := gcm.Open(nil, nonce, encrypted, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, errors.New("decryption failed: invalid key or corrupted data")
        }</span>

        <span class="cov1" title="1">return plaintext, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package crypto

import (
        "crypto/rand"
        "crypto/sha256"

        "golang.org/x/crypto/pbkdf2"
)

const (
        SaltSize   = 32    // длина соли
        Iterations = 10000 //количество итераций
        KeyLength  = 32    //длина ключа
)

// DeriveKey генерирует ключ из пароля и соли с помощью PBKDF2
func DeriveKey(password string, salt []byte) []byte <span class="cov0" title="0">{
        return pbkdf2.Key(
                []byte(password), // пароль
                salt,             // соль
                Iterations,       // количество итераций
                KeyLength,        // длина ключа
                sha256.New,       // хэш-функция
        )
}</span>

// GenerateSalt генерирует случайную соль длиной SaltSize
func GenerateSalt() ([]byte, error) <span class="cov0" title="0">{
        salt := make([]byte, SaltSize)
        _, err := rand.Read(salt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return salt, nil</span>
}

// SHA256 возвращает хеш SHA-256 от входных данных
func SHA256(data []byte) []byte <span class="cov0" title="0">{
        hash := sha256.Sum256(data)
        return hash[:]
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package logger

import (
        "fmt"
        "os"
        "time"

        "gopkg.in/yaml.v3"
)

// Config — конфигурация логгера
type Config struct {
        LogLevel      string `yaml:"log_level"`
        ConsoleFormat string `yaml:"console_format"`
        FileFormat    string `yaml:"file_format"`
        Destination   string `yaml:"destination"`
        FilePattern   string `yaml:"file_pattern"`
}

// LoadConfig загружает конфигурацию из файла
func LoadConfig(path string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// GenerateFileName генерирует имя файла на основе шаблона даты
func GenerateFileName(pattern string) string <span class="cov0" title="0">{
        now := time.Now()
        fileName := now.Format(pattern)
        dir := "./logs"
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create log directory: %v\n", err)
        }</span>
        <span class="cov0" title="0">return fileName</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// pkg/logger/handler/multi.go

package handler

import (
        "context"
        "log/slog"
)

type MultiHandler struct {
        handlers []slog.Handler
}

func NewMultiHandler(handlers ...slog.Handler) *MultiHandler <span class="cov1" title="1">{
        return &amp;MultiHandler{handlers: handlers}
}</span>

func (m *MultiHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov10" title="5">{
        for _, h := range m.handlers </span><span class="cov10" title="5">{
                if h.Enabled(ctx, level) </span><span class="cov10" title="5">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (m *MultiHandler) Handle(ctx context.Context, r slog.Record) error <span class="cov10" title="5">{
        for _, h := range m.handlers </span><span class="cov10" title="5">{
                if err := h.Handle(ctx, r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov10" title="5">return nil</span>
}

func (m *MultiHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        newHandlers := make([]slog.Handler, len(m.handlers))
        for i, h := range m.handlers </span><span class="cov0" title="0">{
                newHandlers[i] = h.WithAttrs(attrs)
        }</span>
        <span class="cov0" title="0">return NewMultiHandler(newHandlers...)</span>
}

func (m *MultiHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        newHandlers := make([]slog.Handler, len(m.handlers))
        for i, h := range m.handlers </span><span class="cov0" title="0">{
                newHandlers[i] = h.WithGroup(name)
        }</span>
        <span class="cov0" title="0">return NewMultiHandler(newHandlers...)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// pkg/logger/handler/text.go

package handler

import (
        "context"
        "fmt"
        "io"
        "os"
        "time"

        "log/slog"

        "golang.org/x/term"
)

type TextHandler struct {
        out       io.Writer
        level     slog.Level
        isColored bool
}

func NewTextHandler(out io.Writer, level slog.Level) *TextHandler <span class="cov1" title="1">{
        isColored := false
        if f, ok := out.(*os.File); ok &amp;&amp; term.IsTerminal(int(f.Fd())) </span><span class="cov0" title="0">{
                isColored = true
        }</span>
        <span class="cov1" title="1">return &amp;TextHandler{
                out:       out,
                level:     level,
                isColored: isColored,
        }</span>
}

func (h *TextHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov10" title="5">{
        return level &gt;= h.level
}</span>

func (h *TextHandler) Handle(ctx context.Context, r slog.Record) error <span class="cov10" title="5">{
        level := r.Level.String()

        if h.isColored </span><span class="cov0" title="0">{
                switch level </span>{
                case "DEBUG":<span class="cov0" title="0">
                        fmt.Fprintf(h.out, "\033[34m")</span> // Синий
                case "WARN":<span class="cov0" title="0">
                        fmt.Fprintf(h.out, "\033[33m")</span> // Жёлтый
                case "ERROR":<span class="cov0" title="0">
                        fmt.Fprintf(h.out, "\033[31m")</span> // Красный
                }
        }

        <span class="cov10" title="5">fmt.Fprintf(h.out, "%s [%s] %s",
                r.Time.Format(time.RFC3339),
                level,
                r.Message,
        )

        r.Attrs(func(a slog.Attr) bool </span><span class="cov4" title="2">{
                fmt.Fprintf(h.out, " %s=%v", a.Key, a.Value)
                return true
        }</span>)

        <span class="cov10" title="5">fmt.Fprintln(h.out)
        if h.isColored </span><span class="cov0" title="0">{
                fmt.Fprintf(h.out, "\033[0m")
        }</span>
        <span class="cov10" title="5">return nil</span>
}

func (h *TextHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return h
}</span>

func (h *TextHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return h
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// pkg/logger/init.go

package logger

import (
        "fmt"
        "io"
        "os"

        "log/slog"

        "github.com/dvkhr/gophkeeper/pkg/logger/handler"
)

// InitLogger инициализирует логгер из конфигурации.
func InitLogger(configPath string) error <span class="cov1" title="1">{
        var err error
        loggerOnce.Do(func() </span><span class="cov1" title="1">{
                // Загружаем конфигурацию
                cfg, loadErr := LoadConfig(configPath)
                if loadErr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("failed to load logger config: %w", loadErr)
                        return
                }</span>

                // Получаем параметры логгера из конфигурации
                <span class="cov1" title="1">logLevel := cfg.LogLevel
                consoleFormat := cfg.ConsoleFormat
                fileFormat := cfg.FileFormat
                destination := cfg.Destination
                filePattern := cfg.FilePattern

                level := GetLogLevel(logLevel)
                if level == slog.Level(-999) </span><span class="cov0" title="0">{
                        Logg = &amp;Logger{
                                logger: slog.New(slog.NewJSONHandler(io.Discard, nil)),
                        }
                        return
                }</span>

                <span class="cov1" title="1">var handlers []slog.Handler

                // Обработчик для терминала
                if destination == "console" || destination == "both" </span><span class="cov1" title="1">{
                        var consoleHandler slog.Handler
                        switch consoleFormat </span>{
                        case "text":<span class="cov1" title="1">
                                consoleHandler = handler.NewTextHandler(os.Stdout, level)</span>
                        case "json":<span class="cov0" title="0">
                                consoleHandler = slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: level})</span>
                        default:<span class="cov0" title="0">
                                consoleHandler = slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: level})</span>
                        }
                        <span class="cov1" title="1">handlers = append(handlers, consoleHandler)</span>
                }

                // Обработчик для файла
                <span class="cov1" title="1">if destination == "file" || destination == "both" </span><span class="cov0" title="0">{
                        fileName := GenerateFileName(filePattern)
                        file, openErr := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                        if openErr != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to open log file: %v\n", openErr)
                        }</span> else<span class="cov0" title="0"> {
                                var fileHandler slog.Handler
                                switch fileFormat </span>{
                                case "text":<span class="cov0" title="0">
                                        fileHandler = handler.NewTextHandler(file, level)</span>
                                case "json":<span class="cov0" title="0">
                                        fileHandler = slog.NewJSONHandler(file, &amp;slog.HandlerOptions{Level: level})</span>
                                default:<span class="cov0" title="0">
                                        fileHandler = slog.NewJSONHandler(file, &amp;slog.HandlerOptions{Level: level})</span>
                                }
                                <span class="cov0" title="0">handlers = append(handlers, fileHandler)</span>
                        }
                }

                // Если нет обработчиков, используем консоль по умолчанию
                <span class="cov1" title="1">if len(handlers) == 0 </span><span class="cov0" title="0">{
                        handlers = append(handlers, slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: level}))
                }</span>

                // Инициализируем логгер
                <span class="cov1" title="1">Logg = &amp;Logger{
                        logger: slog.New(handler.NewMultiHandler(handlers...)),
                }</span>
        })
        <span class="cov1" title="1">return err</span>
}

// InitTestLogger инициализирует тестовый логгер с уровнем логгирования "none".
func InitTestLogger() error <span class="cov0" title="0">{
        var err error
        loggerOnce.Do(func() </span><span class="cov0" title="0">{
                // Уровень логгирования "none" — отключаем все логи
                level := slog.Level(-999)

                // Создаем обработчик, который игнорирует все логи
                handler := slog.NewJSONHandler(io.Discard, &amp;slog.HandlerOptions{Level: level})

                // Инициализируем глобальный логгер
                Logg = &amp;Logger{
                        logger: slog.New(handler),
                }
        }</span>)
        <span class="cov0" title="0">return err</span>
}

// NewTestLogger создаёт новый логгер для тестов
func NewTestLogger() *Logger <span class="cov10" title="29">{
        return &amp;Logger{
                logger: slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                        Level: slog.LevelDebug,
                })),
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package logger

import "log/slog"

// GetLogLevel преобразует строку уровня лога в slog.Level
func GetLogLevel(level string) slog.Level <span class="cov8" title="1">{
        switch level </span>{
        case "debug":<span class="cov8" title="1">
                return slog.LevelDebug</span>
        case "info":<span class="cov0" title="0">
                return slog.LevelInfo</span>
        case "warn":<span class="cov0" title="0">
                return slog.LevelWarn</span>
        case "error":<span class="cov0" title="0">
                return slog.LevelError</span>
        default:<span class="cov0" title="0">
                return slog.LevelInfo</span> // По умолчанию используем Info
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package logger

import (
        "log/slog"
        "sync"
)

type Logger struct {
        logger *slog.Logger
}

var (
        Logg       *Logger
        loggerOnce sync.Once
)

func (l *Logger) Info(msg string, attrs ...any) <span class="cov10" title="127">{
        l.logger.Info(msg, attrs...)
}</span>

func (l *Logger) Warn(msg string, attrs ...any) <span class="cov0" title="0">{
        l.logger.Warn(msg, attrs...)
}</span>

func (l *Logger) Error(msg string, attrs ...any) <span class="cov1" title="1">{
        l.logger.Error(msg, attrs...)
}</span>

func (l *Logger) Debug(msg string, attrs ...any) <span class="cov6" title="25">{
        l.logger.Debug(msg, attrs...)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package logger

import (
        "regexp"
)

// MaskSensitiveData скрывает значения чувствительных полей в JSON-строке
func MaskSensitiveData(body string) string <span class="cov0" title="0">{
        re := regexp.MustCompile(`("(password|token)"\s*:\s*")([^"]*)`)
        return re.ReplaceAllString(body, `$1***`)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package main

import (
        "fmt"
        "net"
        "os"
        "os/signal"
        "syscall"

        "github.com/dvkhr/gophkeeper/pb"
        "github.com/dvkhr/gophkeeper/pkg/logger"
        "github.com/dvkhr/gophkeeper/server/internal/api"
        "github.com/dvkhr/gophkeeper/server/internal/auth"
        "github.com/dvkhr/gophkeeper/server/internal/config"
        "github.com/dvkhr/gophkeeper/server/internal/db"
        "github.com/dvkhr/gophkeeper/server/internal/repository"
        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        // Инициализируем логгер
        if err := logger.InitLogger("/home/max/go/src/GophKeeper/configs/logger.yaml"); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>

        // Парсим флаги командной строки
        <span class="cov0" title="0">config.ParseFlags()
        logger.Logg.Info("Using config file", "path", config.ConfigFile)

        // Загрузка основной конфигурации
        cfg, err := config.Load(config.ConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to load config", "error", err)
                panic(err)</span>
        }

        // Подключение к базе данных
        <span class="cov0" title="0">dbConn, err := db.Connect(cfg.Database.DSN)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to connect to DB", "error", err)
                return
        }</span>
        <span class="cov0" title="0">defer dbConn.Close()

        if err := db.ApplyMigrations(dbConn); err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to apply migrations", "error", err)
                return
        }</span>

        <span class="cov0" title="0">logger.Logg.Info("Database is ready. Starting server...")

        repo := repository.NewPostgresRepository(dbConn)
        server := api.NewKeeperServer(repo, cfg)

        // Подготовка gRPC сервера
        lis, err := net.Listen("tcp", fmt.Sprintf(":%d", cfg.Server.Port))
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to listen", "error", err)
                panic(err)</span>
        }
        <span class="cov0" title="0">interceptor := auth.AuthInterceptor(*cfg, repo)

        grpcServer := grpc.NewServer(
                grpc.UnaryInterceptor(interceptor),
        )

        pb.RegisterKeeperServiceServer(grpcServer, server)
        logger.Logg.Info("Starting gRPC server",
                "port", cfg.Server.Port,
                "mode", cfg.Server.Mode,
                "dsn", cfg.Database.DSN,
                "jwt_ttl_Hours", cfg.Auth.JWTTTLHours,
                "jwt_ttl_Minutes", cfg.Auth.JWTTTLMinutes,
        )

        go func() </span><span class="cov0" title="0">{
                if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        logger.Logg.Error("Failed to serve", "error", err)
                        panic(err)</span>
                }
        }()

        <span class="cov0" title="0">logger.Logg.Info("Server is running...")

        c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt, syscall.SIGTERM)
        &lt;-c
        logger.Logg.Info("Shutting down server...")
        grpcServer.GracefulStop()</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package api реализует gRPC-сервер для GophKeeper.
// Предоставляет методы для:
// - регистрации и входа пользователей,
// - хранения и получения зашифрованных данных,
// - синхронизации данных между клиентом и сервером.
//
// Сервер использует:
// - JWT для аутентификации,
// - refresh-токены для долгосрочной сессии,
// - репозитории для работы с базой данных,
// - middleware для проверки токенов.
package api

import (
        "context"
        "database/sql"
        "strings"

        "github.com/dvkhr/gophkeeper/pb"
        "github.com/dvkhr/gophkeeper/pkg/logger"
        "github.com/dvkhr/gophkeeper/server/internal/auth"
        "github.com/dvkhr/gophkeeper/server/internal/config"
        "github.com/dvkhr/gophkeeper/server/internal/repository"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// KeeperServer реализует gRPC-сервис KeeperService.
// Хранит репозиторий и конфигурацию для доступа к БД, аутентификации и генерации токенов.
type KeeperServer struct {
        pb.UnimplementedKeeperServiceServer
        repo repository.Repository
        cfg  *config.Config
}

// NewKeeperServer создаёт новый экземпляр KeeperServer.
func NewKeeperServer(repo repository.Repository, cfg *config.Config) *KeeperServer <span class="cov10" title="25">{
        return &amp;KeeperServer{
                repo: repo,
                cfg:  cfg,
        }
}</span>

// Register обрабатывает запрос на регистрацию нового пользователя.
// Ожидает зашифрованный пароль (EncryptedPassword) от клиента.
// Хэширует пароль и сохраняет пользователя в БД.
// Возвращает пару токенов: access и refresh.
func (s *KeeperServer) Register(ctx context.Context, req *pb.RegisterRequest) (*pb.AuthResponse, error) <span class="cov9" title="23">{
        logger.Logg.Info("Register request", "login", req.Login)

        hashedPassword, err := auth.HashPassword(string(req.EncryptedPassword))
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to hash password", "error", err)
                return nil, err
        }</span>

        <span class="cov9" title="23">userID, err := s.repo.CreateUser(req.Login, hashedPassword)
        if err != nil </span><span class="cov1" title="1">{
                logger.Logg.Error("Register failed", "error", err)

                // Проверяем, что это ошибка дубликата
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") </span><span class="cov1" title="1">{
                        return nil, status.Errorf(codes.AlreadyExists, "user with this login already exists")
                }</span>

                <span class="cov0" title="0">return nil, status.Errorf(codes.Internal, "failed to create user")</span>
        }

        <span class="cov9" title="22">refreshToken, err := auth.GenerateRefreshToken(s.repo, userID, *s.cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to generate refresh token", "error", err)
                return nil, err
        }</span>

        <span class="cov9" title="22">accessToken, err := auth.GenerateToken(*s.cfg, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to generate access token", "error", err)
                return nil, err
        }</span>
        <span class="cov9" title="22">logger.Logg.Info("Register: user create", "user_id", userID, "login", req.Login)

        return &amp;pb.AuthResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                UserId:       userID,
        }, nil</span>
}

// Login обрабатывает запрос на вход.
// Проверяет логин и зашифрованный пароль.
// Если данные верны — возвращает пару токенов.
func (s *KeeperServer) Login(ctx context.Context, req *pb.LoginRequest) (*pb.AuthResponse, error) <span class="cov4" title="3">{
        logger.Logg.Info("Login request", "login", req.Login)

        user, err := s.repo.GetUserByLogin(req.Login)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Login failed", "error", err)
                return nil, err
        }</span>
        <span class="cov4" title="3">if user == nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.NotFound, "User not found")
        }</span>

        <span class="cov2" title="2">if !auth.CheckPasswordHash(string(req.EncryptedPassword), user.PasswordHash) </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Unauthenticated, "Invalid credentials")
        }</span>

        <span class="cov1" title="1">refreshToken, err := auth.GenerateRefreshToken(s.repo, user.ID, *s.cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to generate refresh token", "error", err)
                return nil, err
        }</span>

        <span class="cov1" title="1">accessToken, err := auth.GenerateToken(*s.cfg, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to generate access token", "error", err)
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;pb.AuthResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
        }, nil</span>
}

// StoreData сохраняет зашифрованные данные пользователя в системе.
// Проверяет, что пользователь авторизован (userID в контексте).
// Проверяет, что запись и её ID не пустые.
// Сохраняет или обновляет данные через репозиторий.
func (s *KeeperServer) StoreData(ctx context.Context, req *pb.StoreDataRequest) (*pb.StatusResponse, error) <span class="cov7" title="10">{
        userID, ok := auth.GetUserID(ctx)
        if !ok </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Unauthenticated, "Missing user ID in context")
        }</span>

        <span class="cov7" title="9">if req.Record == nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "Record is required")
        }</span>

        <span class="cov6" title="8">if req.Record.Id == "" </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "Record ID is required")
        }</span>

        <span class="cov6" title="7">logger.Logg.Info("Storing data", "type", req.Record.Type, "user", userID)

        err := s.repo.SaveData(userID, req.Record)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to store data", "error", err)
                return nil, status.Errorf(codes.Internal, "Failed to save data")
        }</span>

        <span class="cov6" title="7">return &amp;pb.StatusResponse{
                Success: true,
                Message: "Data stored successfully",
        }, nil</span>
}

// GetData возвращает все неудалённые данные пользователя.
// Проверяет, что пользователь авторизован (userID в контексте).
// Загружает все записи из БД через репозиторий.
func (s *KeeperServer) GetData(ctx context.Context, req *pb.GetDataRequest) (*pb.DataResponse, error) <span class="cov6" title="6">{
        userID, ok := auth.GetUserID(ctx)
        if !ok </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Unauthenticated, "Missing user ID in context")
        }</span>

        <span class="cov5" title="5">logger.Logg.Info("Getting all data", "user", userID)

        records, err := s.repo.GetAllData(userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to get data", "error", err)
                return nil, status.Errorf(codes.Internal, "Failed to retrieve data")
        }</span>

        <span class="cov5" title="5">return &amp;pb.DataResponse{
                Records: records,
        }, nil</span>
}

// SyncData синхронизирует клиентские данные с сервером.
// Проверяет, что пользователь авторизован (userID в контексте).
// Сохраняет все записи.
// Возвращает все неудаленные данные с сервера.
func (s *KeeperServer) SyncData(ctx context.Context, req *pb.SyncRequest) (*pb.SyncResponse, error) <span class="cov5" title="5">{
        userID, ok := auth.GetUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Unauthenticated, "Missing user ID in context")
        }</span>

        <span class="cov5" title="5">logger.Logg.Info("Syncing data", "count", len(req.Records), "user", userID)

        // сохраняем
        for _, record := range req.Records </span><span class="cov6" title="7">{
                if record == nil || record.Id == "" </span><span class="cov2" title="2">{
                        continue</span> // пропускаем невалидные
                }
                <span class="cov5" title="5">if err := s.repo.SaveData(userID, record); err != nil </span><span class="cov0" title="0">{
                        logger.Logg.Error("Failed to sync record", "id", record.Id, "error", err)
                }</span>
        }

        // получаем с сервера
        <span class="cov5" title="5">remoteRecords, err := s.repo.GetAllData(userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to fetch remote data", "error", err)
                return nil, status.Errorf(codes.Internal, "Failed to retrieve remote data")
        }</span>

        <span class="cov5" title="5">return &amp;pb.SyncResponse{
                Records: remoteRecords,
        }, nil</span>
}

// DeleteData помечает запись как удалённую (soft delete).
// Проверяет, что пользователь авторизован.
// Проверяет, что запись существует и принадлежит пользователю.
// Устанавливает флаг "deleted = true" в БД.
func (s *KeeperServer) DeleteData(ctx context.Context, req *pb.DeleteDataRequest) (*pb.StatusResponse, error) <span class="cov6" title="6">{
        userID, ok := auth.GetUserID(ctx)
        if !ok </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Unauthenticated, "Missing user ID in context")
        }</span>

        <span class="cov5" title="5">logger.Logg.Info("Deleting data", "record_id", req.Id, "user", userID)

        if req.Id == "" </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "Record ID is required")
        }</span>

        // Проверяем, существует ли запись и принадлежит ли пользователю
        <span class="cov4" title="4">exists, err := s.repo.DataExistsForUser(req.Id, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to check data ownership", "error", err)
                return nil, status.Errorf(codes.Internal, "Failed to verify data ownership")
        }</span>
        <span class="cov4" title="4">if !exists </span><span class="cov2" title="2">{
                return nil, status.Errorf(codes.NotFound, "Data not found or access denied")
        }</span>

        <span class="cov2" title="2">err = s.repo.MarkDataAsDeleted(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to delete data", "error", err)
                return nil, status.Errorf(codes.Internal, "Failed to delete data")
        }</span>

        <span class="cov2" title="2">return &amp;pb.StatusResponse{
                Success: true,
                Message: "Data deleted successfully",
        }, nil</span>
}

func (s *KeeperServer) Refresh(ctx context.Context, req *pb.RefreshRequest) (*pb.AuthResponse, error) <span class="cov2" title="2">{
        revoked, err := s.repo.IsRefreshTokenRevoked(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to check token status")
        }</span>
        <span class="cov2" title="2">if revoked </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Unauthenticated, "token revoked")
        }</span>

        <span class="cov1" title="1">userID, err := s.repo.GetUserIDByRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Unauthenticated, "invalid refresh token")
                }</span>
                <span class="cov0" title="0">return nil, status.Error(codes.Internal, "failed to get user ID")</span>
        }

        <span class="cov1" title="1">newAccessToken, err := auth.GenerateToken(*s.cfg, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to generate access token")
        }</span>

        <span class="cov1" title="1">newRefreshToken, err := auth.GenerateRefreshToken(s.repo, userID, *s.cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to generate refresh token")
        }</span>

        <span class="cov1" title="1">err = s.repo.RevokeRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to revoke old token")
        }</span>

        <span class="cov1" title="1">return &amp;pb.AuthResponse{
                AccessToken:  newAccessToken,
                RefreshToken: newRefreshToken,
                UserId:       userID,
        }, nil</span>
}

// Logout отзывает refresh_token
func (s *KeeperServer) Logout(ctx context.Context, req *pb.LogoutRequest) (*pb.LogoutResponse, error) <span class="cov1" title="1">{
        err := s.repo.RevokeRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "failed to revoke token")
        }</span>
        <span class="cov1" title="1">return &amp;pb.LogoutResponse{Success: true}, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package auth предоставляет функции аутентификации и авторизации для GophKeeper.
// Включает:
// - генерацию и парсинг JWT-токенов,
// - работу с refresh-токенами,
// - хэширование и проверку паролей,
// - контекстный интерсептор для gRPC.
package auth

import (
        "time"

        "github.com/dvkhr/gophkeeper/pkg/logger"
        "github.com/dvkhr/gophkeeper/server/internal/config"
        "github.com/golang-jwt/jwt/v5"
)

// Claims — структура полезной нагрузки (payload) JWT-токена.
// Включает идентификатор пользователя и стандартные claims (ExpiresAt, IssuedAt, Issuer и др.).
type Claims struct {
        UserID string `json:"user_id"`
        jwt.RegisteredClaims
}

// GenerateToken — создаёт новый JWT-токен для пользователя
func GenerateToken(cfg config.Config, userID string) (string, error) <span class="cov8" title="1">{
        ttl := time.Duration(cfg.Auth.JWTTTLHours)*time.Hour +
                time.Duration(cfg.Auth.JWTTTLMinutes)*time.Minute

        if ttl == 0 </span><span class="cov0" title="0">{
                ttl = 1 * time.Minute
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC()
        expiresAt := now.Add(ttl)

        claims := &amp;Claims{
                UserID: userID,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiresAt),
                        IssuedAt:  jwt.NewNumericDate(now),
                        Issuer:    "GophKeeper",
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(cfg.Auth.JWTSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">logger.Logg.Debug("Generated access token", "exp", expiresAt, "ttl", ttl)
        return tokenString, nil</span>
}

// ParseToken — разбирает строку токена и возвращает claims.
// Возвращает ошибку, если токен недействителен или подпись не совпадает.
func ParseToken(cfg config.Config, tokenStr string) (*Claims, error) <span class="cov8" title="1">{
        keyFunc := func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, jwt.ErrSignatureInvalid
                }</span>
                <span class="cov8" title="1">return []byte(cfg.Auth.JWTSecret), nil</span>
        }

        <span class="cov8" title="1">token, err := jwt.ParseWithClaims(tokenStr, &amp;Claims{}, keyFunc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, jwt.ErrInvalidKey
        }</span>

        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, jwt.ErrTokenExpired
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package auth

import "context"

// Используется для безопасной передачи идентификатора пользователя в контексте.
// userIDKey — приватный тип ключа для хранения идентификатора пользователя в контексте.
type userIDKey struct{}

// WithUserID добавляет идентификатор пользователя в контекст.
func WithUserID(ctx context.Context, userID string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, userIDKey{}, userID)
}</span>

// GetUserID извлекает идентификатор пользователя из контекста.
func GetUserID(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        userID, ok := ctx.Value(userIDKey{}).(string)
        return userID, ok
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// pkg/auth/middleware.go

package auth

import (
        "context"
        "strings"

        "github.com/dvkhr/gophkeeper/pkg/logger"
        "github.com/dvkhr/gophkeeper/server/internal/config"
        "github.com/dvkhr/gophkeeper/server/internal/repository"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// AuthInterceptor — gRPC middleware для проверки JWT-токена в заголовках.
// Пропускает методы /keeper.KeeperService/Login и /keeper.KeeperService/Register без проверки.
// Для остальных методов:
// - извлекает Bearer-токен,
// - проверяет его валидность,
// - проверяет, не отозван ли он,
// - добавляет userID в контекст.
func AuthInterceptor(cfg config.Config, repo repository.TokenRepository) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                if info.FullMethod == "/keeper.KeeperService/Login" ||
                        info.FullMethod == "/keeper.KeeperService/Register" ||
                        info.FullMethod == "/keeper.KeeperService/Refresh" ||
                        info.FullMethod == "/keeper.KeeperService/Logout" </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        logger.Logg.Warn("Metadata not provided")

                        return nil, status.Errorf(codes.Unauthenticated, "metadata not provided")
                }</span>

                <span class="cov0" title="0">values := md["authorization"]
                if len(values) == 0 </span><span class="cov0" title="0">{
                        logger.Logg.Warn("Authorization header not provided")

                        return nil, status.Errorf(codes.Unauthenticated, "authorization not provided")
                }</span>

                <span class="cov0" title="0">tokenStr := strings.TrimPrefix(values[0], "Bearer ")
                if tokenStr == "" </span><span class="cov0" title="0">{
                        logger.Logg.Warn("Empty token")

                        return nil, status.Errorf(codes.Unauthenticated, "empty token")
                }</span>

                <span class="cov0" title="0">claims, err := ParseToken(cfg, tokenStr)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Logg.Warn("Invalid token", "error", err)

                        return nil, status.Errorf(codes.Unauthenticated, "invalid token: %v", err)
                }</span>

                <span class="cov0" title="0">ctx = WithUserID(ctx, claims.UserID)
                logger.Logg.Debug("User ID установлен в контекст", "user_id", claims.UserID)

                return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package auth

import (
        "golang.org/x/crypto/bcrypt"
)

// HashPassword хэширует пароль с использованием bcrypt.
// Возвращает хэш и ошибку, если хэширование не удалось.
func HashPassword(password string) (string, error) <span class="cov1" title="1">{
        hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(hashed), err
}</span>

// CheckPasswordHash проверяет, совпадает ли пароль с хэшем.
// Возвращает true, если пароль совпадает, и false в противном случае.
func CheckPasswordHash(password, hash string) bool <span class="cov10" title="3">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// pkg/auth/token.go

package auth

import (
        "crypto/rand"
        "encoding/base64"
        "time"

        "github.com/dvkhr/gophkeeper/server/internal/config"
        "github.com/dvkhr/gophkeeper/server/internal/repository"
)

// GenerateRefreshToken генерирует случайный refresh-токен и сохраняет его в БД.
// Токен действителен в течение RefreshTokenTTLDays дней.
func GenerateRefreshToken(repo repository.TokenRepository, userID string, cfg config.Config) (string, error) <span class="cov0" title="0">{
        token := GenerateRandomString(32)
        expiresAt := time.Now().Add(time.Duration(cfg.Auth.RefreshTokenTTLDays) * 24 * time.Hour)

        err := repo.SaveRefreshToken(token, userID, expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return token, nil</span>
}

// RevokeRefreshToken отзывает refresh-токен.
func RevokeRefreshToken(repo repository.TokenRepository, token string) error <span class="cov0" title="0">{
        return repo.RevokeRefreshToken(token)
}</span>

// GenerateRandomString генерирует случайную строку указанной длины.
// Используется для создания refresh-токенов.
func GenerateRandomString(n int) string <span class="cov0" title="0">{
        b := make([]byte, n)
        _, _ = rand.Read(b)
        return base64.URLEncoding.EncodeToString(b)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// config/config.go

package config

import (
        "os"

        "gopkg.in/yaml.v3"
)

// AuthConfig — конфигурация для JWT и refresh-токенов
type AuthConfig struct {
        JWTSecret           string `yaml:"jwt_secret"`
        JWTTTLHours         int    `yaml:"jwt_ttl_hours"`
        JWTTTLMinutes       int    `yaml:"jwt_ttl_minutes"`
        RefreshTokenTTLDays int    `yaml:"refresh_token_ttl_days"`
}

// Config — основная структура конфигурации приложения
type Config struct {
        Server struct {
                Port int    `yaml:"port"`
                Mode string `yaml:"mode"`
        } `yaml:"server"`

        Database struct {
                DSN string `yaml:"dsn"`
        } `yaml:"database"`

        Auth AuthConfig `yaml:"auth"`
}

// Load загружает конфигурацию из указанного YAML-файла
func Load(path string) (*Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cfg := &amp;Config{}
        if err := yaml.Unmarshal(data, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package config

import (
        "flag"
        "os"
)

var (
        ConfigFile string
)

func ParseFlags() <span class="cov0" title="0">{
        flag.StringVar(&amp;ConfigFile, "config", getDefaultConfigPath(), "Path to config file")

        flag.Parse()
}</span>

func getDefaultConfigPath() string <span class="cov0" title="0">{
        if env := os.Getenv("CONFIG_FILE"); env != "" </span><span class="cov0" title="0">{
                return env
        }</span>
        <span class="cov0" title="0">return "/home/max/go/src/GophKeeper/configs/config.yaml"</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package db предоставляет функции для подключения к базе данных и применения миграций.
package db

import (
        "database/sql"
        "fmt"

        "github.com/dvkhr/gophkeeper/pkg/logger"
        _ "github.com/jackc/pgx/v5/stdlib"
)

// Connect устанавливает соединение с базой данных PostgreSQL по заданной строке подключения (DSN).
//
// Возвращает:
//   - *sql.DB — указатель на объект базы данных.
//   - error — ошибку, если подключение не удалось установить.
func Connect(dsn string) (*sql.DB, error) <span class="cov10" title="2">{
        db, err := sql.Open("pgx", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov10" title="2">if err := db.Ping(); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov1" title="1">logger.Logg.Info("Connected to the database")
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package db

import (
        "database/sql"
        "embed"
        "fmt"
        "io/fs"

        "github.com/dvkhr/gophkeeper/pkg/logger"
)

//go:embed migrations/*.sql
var migrationFiles embed.FS

// ApplyMigrations применяет SQL-миграции из embed.FS.
//
// Принимает:
//   - db *sql.DB — открытое соединение с базой данных.
//
// Возвращает:
//   - error — ошибку, если какая-либо миграция не была применена.
func ApplyMigrations(db *sql.DB) error <span class="cov1" title="1">{
        logger.Logg.Info("Running database migrations...")

        files, err := fs.ReadDir(migrationFiles, "migrations")
        if err != nil </span><span class="cov0" title="0">{
                logger.Logg.Error("Failed to read migration files", "error", err)
                return fmt.Errorf("failed to read migration files: %w", err)
        }</span>

        <span class="cov1" title="1">for _, file := range files </span><span class="cov10" title="2">{
                if !file.Type().IsRegular() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="2">migrationName := file.Name()
                logger.Logg.Info("Applying migration", "name", migrationName)

                content, err := fs.ReadFile(migrationFiles, "migrations/"+migrationName)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Logg.Error("Failed to read migration file", "name", migrationName, "error", err)
                        return fmt.Errorf("failed to read %s: %w", migrationName, err)
                }</span>

                <span class="cov10" title="2">_, err = db.Exec(string(content))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Logg.Error("Failed to apply migration", "name", migrationName, "error", err)
                        return fmt.Errorf("failed to apply %s: %w", migrationName, err)
                }</span>
        }

        <span class="cov1" title="1">logger.Logg.Info("All migrations applied successfully.")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package repository

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"

        "github.com/dvkhr/gophkeeper/pb"
)

var _ DataRepository = (*PostgresDataRepository)(nil)

// DataRepository — интерфейс для работы с данными пользователя в базе данных.
type DataRepository interface {
        // SaveData сохраняет или обновляет запись пользователя в базе данных.
        SaveData(userID string, data *pb.DataRecord) error

        // GetAllData возвращает все неудалённые данные пользователя.
        // Данные возвращаются в порядке убывания времени обновления.
        GetAllData(userID string) ([]*pb.DataRecord, error)

        // DataExistsForUser проверяет, принадлежит ли запись пользователю
        DataExistsForUser(id, userID string) (bool, error)

        // MarkDataAsDeleted помечает запись как удаленную
        MarkDataAsDeleted(id string) error
}

// PostgresDataRepository — реализация DataRepository для PostgreSQL.
type PostgresDataRepository struct {
        db *sql.DB
}

// NewDataRepository создаёт новый экземпляр DataRepository.
func NewDataRepository(db *sql.DB) DataRepository <span class="cov8" title="4">{
        return &amp;PostgresDataRepository{db: db}
}</span>

// SaveData сохраняет или обновляет запись пользователя в базе данных.
func (r *PostgresDataRepository) SaveData(userID string, data *pb.DataRecord) error <span class="cov10" title="5">{
        _, err := r.db.ExecContext(context.Background(),
                `INSERT INTO user_data (id, user_id, type, encrypted_data, metadata)
         VALUES ($1, $2, $3, $4, $5)
         ON CONFLICT (id) DO UPDATE SET
                     user_id = EXCLUDED.user_id,
             type = EXCLUDED.type,
             encrypted_data = EXCLUDED.encrypted_data,
             metadata = EXCLUDED.metadata,
             deleted = FALSE,
             updated_at = NOW()`,
                data.Id, userID, data.Type, data.EncryptedData, data.Metadata)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save data: %w", err)
        }</span>
        <span class="cov10" title="5">return nil</span>
}

// GetAllData возвращает все не удалённые данные пользователя из базы данных.
func (r *PostgresDataRepository) GetAllData(userID string) ([]*pb.DataRecord, error) <span class="cov8" title="4">{
        rows, err := r.db.QueryContext(context.Background(),
                `SELECT id, type, encrypted_data, metadata, EXTRACT(EPOCH FROM updated_at)::int
         FROM user_data
         WHERE user_id = $1 AND deleted = false
         ORDER BY updated_at DESC`,
                userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all data: %w", err)
        }</span>
        <span class="cov8" title="4">defer rows.Close()

        var records []*pb.DataRecord
        for rows.Next() </span><span class="cov8" title="4">{
                var (
                        record      pb.DataRecord
                        metadataRaw []byte
                )

                if err := rows.Scan(
                        &amp;record.Id,
                        &amp;record.Type,
                        &amp;record.EncryptedData,
                        &amp;metadataRaw,
                        &amp;record.Timestamp,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>

                // Теперь конвертируем JSON в map[string]string
                <span class="cov8" title="4">if len(metadataRaw) &gt; 0 &amp;&amp; string(metadataRaw) != "null" </span><span class="cov8" title="4">{
                        err = json.Unmarshal(metadataRaw, &amp;record.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
                        }</span>
                }

                <span class="cov8" title="4">records = append(records, &amp;record)</span>
        }

        <span class="cov8" title="4">return records, nil</span>
}

func (r *PostgresDataRepository) DataExistsForUser(id, userID string) (bool, error) <span class="cov0" title="0">{
        var exists bool
        err := r.db.QueryRowContext(context.Background(),
                `SELECT EXISTS(SELECT 1 FROM user_data WHERE id = $1 AND user_id = $2)`,
                id, userID).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check data ownership: %w", err)
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}

func (r *PostgresDataRepository) MarkDataAsDeleted(id string) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(context.Background(),
                `UPDATE user_data SET deleted = TRUE WHERE id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark data as deleted: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package repository

import (
        "database/sql"
        "time"

        "github.com/dvkhr/gophkeeper/pb"
)

// PostgresRepository — объединённая реализация всех репозиториев.
// Использует одно соединение с базой данных для работы с пользователями, данными и токенами.
type PostgresRepository struct {
        userRepo  *PostgresUserRepository
        dataRepo  *PostgresDataRepository
        tokenRepo *PostgresTokenRepository
}

// NewPostgresRepository создаёт новый экземпляр Repository с доступом к PostgreSQL.
// Все подсистемы (пользователи, данные, токены) используют одно соединение с БД.
func NewPostgresRepository(db *sql.DB) Repository <span class="cov0" title="0">{
        return &amp;PostgresRepository{
                userRepo:  &amp;PostgresUserRepository{db: db},
                dataRepo:  &amp;PostgresDataRepository{db: db},
                tokenRepo: &amp;PostgresTokenRepository{db: db},
        }
}</span>

func (r *PostgresRepository) CreateUser(login, passwordHash string) (string, error) <span class="cov0" title="0">{
        return r.userRepo.CreateUser(login, passwordHash)
}</span>

func (r *PostgresRepository) GetUserByLogin(login string) (*User, error) <span class="cov0" title="0">{
        return r.userRepo.GetUserByLogin(login)
}</span>

func (r *PostgresRepository) SaveData(userID string, data *pb.DataRecord) error <span class="cov0" title="0">{
        return r.dataRepo.SaveData(userID, data)
}</span>

func (r *PostgresRepository) GetAllData(userID string) ([]*pb.DataRecord, error) <span class="cov0" title="0">{
        return r.dataRepo.GetAllData(userID)
}</span>

func (r *PostgresRepository) SaveRefreshToken(token, userID string, expiresAt time.Time) error <span class="cov0" title="0">{
        return r.tokenRepo.SaveRefreshToken(token, userID, expiresAt)
}</span>

func (r *PostgresRepository) IsRefreshTokenRevoked(token string) (bool, error) <span class="cov0" title="0">{
        return r.tokenRepo.IsRefreshTokenRevoked(token)
}</span>

func (r *PostgresRepository) RevokeRefreshToken(token string) error <span class="cov0" title="0">{
        return r.tokenRepo.RevokeRefreshToken(token)
}</span>

func (r *PostgresRepository) DataExistsForUser(id string, userID string) (bool, error) <span class="cov0" title="0">{
        return r.dataRepo.DataExistsForUser(id, userID)
}</span>

func (r *PostgresRepository) MarkDataAsDeleted(id string) error <span class="cov0" title="0">{
        return r.dataRepo.MarkDataAsDeleted(id)
}</span>

func (r *PostgresRepository) GetUserIDByRefreshToken(token string) (string, error) <span class="cov0" title="0">{
        return r.tokenRepo.GetUserIDByRefreshToken(token)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"
)

var _ TokenRepository = (*PostgresTokenRepository)(nil)

// TokenRepository — интерфейс для работы с токенами в базе данных.
type TokenRepository interface {
        // SaveRefreshToken сохраняет refresh-токен для пользователя.
        // Возвращает ошибку, если сохранение не удалось.
        SaveRefreshToken(token, userID string, expiresAt time.Time) error

        // IsRefreshTokenRevoked проверяет, был ли refresh-токен отозван.
        // Возвращает true, если токен не найден или отозван.
        IsRefreshTokenRevoked(token string) (bool, error)

        // RevokeRefreshToken отмечает refresh-токен как отозванный.
        // Возвращает ошибку, если операция не удалась.
        RevokeRefreshToken(token string) error

        // GetUserIDByRefreshToken находит и возвращает идентификатор пользователя по значению refresh-токена.
        // Возвращает ошибку sql.ErrNoRows, если токен не найден или отозван.
        GetUserIDByRefreshToken(token string) (string, error)
}

// PostgresTokenRepository — реализация TokenRepository для PostgreSQL.
type PostgresTokenRepository struct {
        db *sql.DB
}

// NewTokenRepository создаёт новый экземпляр TokenRepository.
func NewTokenRepository(db *sql.DB) TokenRepository <span class="cov10" title="3">{
        return &amp;PostgresTokenRepository{db: db}
}</span>

// SaveRefreshToken сохраняет refresh-токен в базе данных.
func (r *PostgresTokenRepository) SaveRefreshToken(token, userID string, expiresAt time.Time) error <span class="cov6" title="2">{
        _, err := r.db.ExecContext(context.Background(),
                `INSERT INTO refresh_tokens (token, user_id, expires_at, revoked)
         VALUES ($1, $2, $3, false)`,
                token, userID, expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save refresh token: %w", err)
        }</span>
        <span class="cov6" title="2">return nil</span>
}

// IsRefreshTokenRevoked проверяет, был ли refresh-токен отозван.
func (r *PostgresTokenRepository) IsRefreshTokenRevoked(token string) (bool, error) <span class="cov10" title="3">{
        var revoked bool
        err := r.db.QueryRow(`
        SELECT revoked FROM refresh_tokens 
        WHERE token = $1
    `, token).Scan(&amp;revoked)
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        return true, nil
                }</span>
                <span class="cov0" title="0">return true, err</span>
        }
        <span class="cov6" title="2">return revoked, nil</span>
}

// RevokeRefreshToken отмечает refresh-токен как отозванный.
func (r *PostgresTokenRepository) RevokeRefreshToken(token string) error <span class="cov1" title="1">{
        _, err := r.db.ExecContext(context.Background(),
                `UPDATE refresh_tokens SET revoked = TRUE WHERE token = $1`, token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to revoke refresh token: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// GetUserIDByRefreshToken находит и возвращает идентификатор пользователя по значению refresh-токена.
func (r *PostgresTokenRepository) GetUserIDByRefreshToken(token string) (string, error) <span class="cov0" title="0">{
        var userID string
        err := r.db.QueryRow(`
        SELECT user_id FROM refresh_tokens 
        WHERE token = $1 AND revoked = false
    `, token).Scan(&amp;userID)
        return userID, err
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
)

var _ UserRepository = (*PostgresUserRepository)(nil)

// UserRepository — интерфейс для работы с пользователями в базе данных.
type UserRepository interface {
        // CreateUser создаёт нового пользователя с указанным логином и хэшем пароля.
        // Возвращает идентификатор созданного пользователя или ошибку.
        CreateUser(login, passwordHash string) (string, error)

        // GetUserByLogin возвращает пользователя по его логину, если он существует и активен.
        // Возвращает nil, если пользователь не найден.
        GetUserByLogin(login string) (*User, error)
}

// PostgresUserRepository — реализация UserRepository для PostgreSQL.
type PostgresUserRepository struct {
        db *sql.DB
}

// NewUserRepository создаёт новый экземпляр UserRepository.
func NewUserRepository(db *sql.DB) UserRepository <span class="cov10" title="10">{
        return &amp;PostgresUserRepository{db: db}
}</span>

// CreateUser создаёт нового пользователя в базе данных.
// Возвращает идентификатор пользователя или ошибку.
func (r *PostgresUserRepository) CreateUser(login, passwordHash string) (string, error) <span class="cov10" title="10">{
        var userID string
        err := r.db.QueryRowContext(context.Background(),
                `INSERT INTO users (login, password_hash) VALUES ($1, $2) RETURNING id`,
                login, passwordHash).Scan(&amp;userID)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to create user: %w", err)
        }</span>
        <span class="cov9" title="9">return userID, nil</span>
}

// GetUserByLogin ищет пользователя по логину в базе данных.
// Возвращает *User, если пользователь найден и активен.
// Возвращает nil, если пользователь не найден.
func (r *PostgresUserRepository) GetUserByLogin(login string) (*User, error) <span class="cov5" title="3">{
        var u User
        err := r.db.QueryRowContext(context.Background(),
                `SELECT id, login, password_hash, status, EXTRACT(EPOCH FROM created_at)::int, EXTRACT(EPOCH FROM updated_at)::int 
         FROM users WHERE login = $1 AND status = 'active'`,
                login).Scan(&amp;u.ID, &amp;u.Login, &amp;u.PasswordHash, &amp;u.Status, &amp;u.CreatedAt, &amp;u.UpdatedAt)

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user by login: %w", err)
        }</span>
        <span class="cov1" title="1">return &amp;u, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
